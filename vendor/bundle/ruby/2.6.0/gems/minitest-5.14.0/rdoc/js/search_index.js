var search_data = {"index":{"searchIndex":["hoe","minitest","kernel","minitest","abstractreporter","assertion","assertions","backtracefilter","benchspec","benchmark","compositereporter","expectations","guard","mock","parallel","executor","test","classmethods","prideio","pridelol","progressreporter","reportable","reporter","result","runnable","skip","spec","dsl","instancemethods","statisticsreporter","summaryreporter","test","lifecyclehooks","unexpectederror","unit","testcase","mockexpectationerror","module","object","<<()","<<()","_()","__run()","after()","after_run()","after_setup()","after_teardown()","assert()","assert_empty()","assert_equal()","assert_in_delta()","assert_in_epsilon()","assert_includes()","assert_instance_of()","assert_kind_of()","assert_match()","assert_mock()","assert_nil()","assert_operator()","assert_output()","assert_path_exists()","assert_performance()","assert_performance_constant()","assert_performance_exponential()","assert_performance_linear()","assert_performance_logarithmic()","assert_performance_power()","assert_predicate()","assert_raises()","assert_respond_to()","assert_same()","assert_send()","assert_silent()","assert_throws()","autorun()","before()","before_setup()","before_teardown()","bench()","bench_exp()","bench_linear()","bench_performance_constant()","bench_performance_exponential()","bench_performance_linear()","bench_performance_logarithmic()","bench_performance_power()","bench_range()","bench_range()","binary_string()","capture_io()","capture_subprocess_io()","describe()","diff()","diff()","diff=()","error?()","exception_details()","expect()","expect()","fail_after()","filter()","fit_error()","fit_exponential()","fit_linear()","fit_logarithmic()","fit_power()","flunk()","from()","i_suck_and_my_tests_are_order_dependent!()","it()","jruby?()","let()","location()","location()","maglev?()","make_my_diffs_pretty!()","message()","methods_matching()","mri?()","mu_pp()","mu_pp_for_diff()","must_be()","must_be_close_to()","must_be_empty()","must_be_instance_of()","must_be_kind_of()","must_be_nil()","must_be_same_as()","must_be_silent()","must_be_within_epsilon()","must_equal()","must_include()","must_match()","must_output()","must_raise()","must_respond_to()","must_throw()","name()","name=()","new()","osx?()","parallelize_me!()","pass()","passed?()","passed?()","passed?()","path_must_exist()","path_wont_exist()","prerecord()","pride()","pride()","pride!()","pride?()","print()","record()","refute()","refute_empty()","refute_equal()","refute_in_delta()","refute_in_epsilon()","refute_includes()","refute_instance_of()","refute_kind_of()","refute_match()","refute_nil()","refute_operator()","refute_path_exists()","refute_predicate()","refute_respond_to()","refute_same()","register_spec_type()","report()","report()","result_code()","result_code()","rubinius?()","run()","run()","run()","run()","run_one_method()","runnable_methods()","runnable_methods()","runnables()","setup()","shutdown()","sigma()","skip()","skip_until()","skipped?()","skipped?()","skipped?()","spec_type()","specify()","start()","start()","stub()","subject()","teardown()","test_order()","things_to_diff()","unknown()","validation_for_fit()","value()","verify()","windows?()","wont_be()","wont_be_close_to()","wont_be_empty()","wont_be_instance_of()","wont_be_kind_of()","wont_be_nil()","wont_be_same_as()","wont_be_within_epsilon()","wont_equal()","wont_include()","wont_match()","wont_respond_to()","history","manifest","readme"],"longSearchIndex":["hoe","hoe::minitest","kernel","minitest","minitest::abstractreporter","minitest::assertion","minitest::assertions","minitest::backtracefilter","minitest::benchspec","minitest::benchmark","minitest::compositereporter","minitest::expectations","minitest::guard","minitest::mock","minitest::parallel","minitest::parallel::executor","minitest::parallel::test","minitest::parallel::test::classmethods","minitest::prideio","minitest::pridelol","minitest::progressreporter","minitest::reportable","minitest::reporter","minitest::result","minitest::runnable","minitest::skip","minitest::spec","minitest::spec::dsl","minitest::spec::dsl::instancemethods","minitest::statisticsreporter","minitest::summaryreporter","minitest::test","minitest::test::lifecyclehooks","minitest::unexpectederror","minitest::unit","minitest::unit::testcase","mockexpectationerror","module","object","minitest::compositereporter#<<()","minitest::parallel::executor#<<()","minitest::spec::dsl::instancemethods#_()","minitest::__run()","minitest::spec::dsl#after()","minitest::after_run()","minitest::test::lifecyclehooks#after_setup()","minitest::test::lifecyclehooks#after_teardown()","minitest::assertions#assert()","minitest::assertions#assert_empty()","minitest::assertions#assert_equal()","minitest::assertions#assert_in_delta()","minitest::assertions#assert_in_epsilon()","minitest::assertions#assert_includes()","minitest::assertions#assert_instance_of()","minitest::assertions#assert_kind_of()","minitest::assertions#assert_match()","minitest::assertions#assert_mock()","minitest::assertions#assert_nil()","minitest::assertions#assert_operator()","minitest::assertions#assert_output()","minitest::assertions#assert_path_exists()","minitest::benchmark#assert_performance()","minitest::benchmark#assert_performance_constant()","minitest::benchmark#assert_performance_exponential()","minitest::benchmark#assert_performance_linear()","minitest::benchmark#assert_performance_logarithmic()","minitest::benchmark#assert_performance_power()","minitest::assertions#assert_predicate()","minitest::assertions#assert_raises()","minitest::assertions#assert_respond_to()","minitest::assertions#assert_same()","minitest::assertions#assert_send()","minitest::assertions#assert_silent()","minitest::assertions#assert_throws()","minitest::autorun()","minitest::spec::dsl#before()","minitest::test::lifecyclehooks#before_setup()","minitest::test::lifecyclehooks#before_teardown()","minitest::benchspec::bench()","minitest::benchmark::bench_exp()","minitest::benchmark::bench_linear()","minitest::benchspec::bench_performance_constant()","minitest::benchspec::bench_performance_exponential()","minitest::benchspec::bench_performance_linear()","minitest::benchspec::bench_performance_logarithmic()","minitest::benchspec::bench_performance_power()","minitest::benchspec::bench_range()","minitest::benchmark::bench_range()","minitest::summaryreporter#binary_string()","minitest::assertions#capture_io()","minitest::assertions#capture_subprocess_io()","kernel#describe()","minitest::assertions::diff()","minitest::assertions#diff()","minitest::assertions::diff=()","minitest::reportable#error?()","minitest::assertions#exception_details()","minitest::mock#expect()","minitest::spec::dsl::instancemethods#expect()","minitest::assertions#fail_after()","minitest::backtracefilter#filter()","minitest::benchmark#fit_error()","minitest::benchmark#fit_exponential()","minitest::benchmark#fit_linear()","minitest::benchmark#fit_logarithmic()","minitest::benchmark#fit_power()","minitest::assertions#flunk()","minitest::result::from()","minitest::test::i_suck_and_my_tests_are_order_dependent!()","minitest::spec::dsl#it()","minitest::guard#jruby?()","minitest::spec::dsl#let()","minitest::assertion#location()","minitest::reportable#location()","minitest::guard#maglev?()","minitest::test::make_my_diffs_pretty!()","minitest::assertions#message()","minitest::runnable::methods_matching()","minitest::guard#mri?()","minitest::assertions#mu_pp()","minitest::assertions#mu_pp_for_diff()","minitest::expectations#must_be()","minitest::expectations#must_be_close_to()","minitest::expectations#must_be_empty()","minitest::expectations#must_be_instance_of()","minitest::expectations#must_be_kind_of()","minitest::expectations#must_be_nil()","minitest::expectations#must_be_same_as()","minitest::expectations#must_be_silent()","minitest::expectations#must_be_within_epsilon()","minitest::expectations#must_equal()","minitest::expectations#must_include()","minitest::expectations#must_match()","minitest::expectations#must_output()","minitest::expectations#must_raise()","minitest::expectations#must_respond_to()","minitest::expectations#must_throw()","minitest::runnable#name()","minitest::runnable#name=()","minitest::parallel::executor::new()","minitest::guard#osx?()","minitest::test::parallelize_me!()","minitest::assertions#pass()","minitest::abstractreporter#passed?()","minitest::reportable#passed?()","minitest::runnable#passed?()","minitest::expectations#path_must_exist()","minitest::expectations#path_wont_exist()","minitest::abstractreporter#prerecord()","minitest::prideio#pride()","minitest::pridelol#pride()","minitest::prideio::pride!()","minitest::prideio::pride?()","minitest::prideio#print()","minitest::abstractreporter#record()","minitest::assertions#refute()","minitest::assertions#refute_empty()","minitest::assertions#refute_equal()","minitest::assertions#refute_in_delta()","minitest::assertions#refute_in_epsilon()","minitest::assertions#refute_includes()","minitest::assertions#refute_instance_of()","minitest::assertions#refute_kind_of()","minitest::assertions#refute_match()","minitest::assertions#refute_nil()","minitest::assertions#refute_operator()","minitest::assertions#refute_path_exists()","minitest::assertions#refute_predicate()","minitest::assertions#refute_respond_to()","minitest::assertions#refute_same()","minitest::spec::dsl#register_spec_type()","minitest::abstractreporter#report()","minitest::statisticsreporter#report()","minitest::reportable#result_code()","minitest::runnable#result_code()","minitest::guard#rubinius?()","minitest::run()","minitest::runnable#run()","minitest::runnable::run()","minitest::test#run()","minitest::runnable::run_one_method()","minitest::runnable::runnable_methods()","minitest::test::runnable_methods()","minitest::runnable::runnables()","minitest::test::lifecyclehooks#setup()","minitest::parallel::executor#shutdown()","minitest::benchmark#sigma()","minitest::assertions#skip()","minitest::assertions#skip_until()","minitest::assertions#skipped?()","minitest::reportable#skipped?()","minitest::runnable#skipped?()","minitest::spec::dsl#spec_type()","minitest::spec::dsl#specify()","minitest::abstractreporter#start()","minitest::parallel::executor#start()","object#stub()","minitest::spec::dsl#subject()","minitest::test::lifecyclehooks#teardown()","minitest::test::test_order()","minitest::assertions#things_to_diff()","minitest#unknown()","minitest::benchmark#validation_for_fit()","minitest::spec::dsl::instancemethods#value()","minitest::mock#verify()","minitest::guard#windows?()","minitest::expectations#wont_be()","minitest::expectations#wont_be_close_to()","minitest::expectations#wont_be_empty()","minitest::expectations#wont_be_instance_of()","minitest::expectations#wont_be_kind_of()","minitest::expectations#wont_be_nil()","minitest::expectations#wont_be_same_as()","minitest::expectations#wont_be_within_epsilon()","minitest::expectations#wont_equal()","minitest::expectations#wont_include()","minitest::expectations#wont_match()","minitest::expectations#wont_respond_to()","","",""],"info":[["Hoe","","Hoe.html","",""],["Hoe::Minitest","","Hoe/Minitest.html","",""],["Kernel","","Kernel.html","","<p>Kernel extensions for minitest\n"],["Minitest","","Minitest.html","","<p>minitest/{test,spec,mock,benchmark}\n<p>home  &mdash; github.com/seattlerb/minitest\n<p>bugs  &mdash; github.com/seattlerb/minitest/issues …\n"],["Minitest::AbstractReporter","","Minitest/AbstractReporter.html","","<p>Defines the API for Reporters. Subclass this and override whatever you want. Go nuts.\n"],["Minitest::Assertion","","Minitest/Assertion.html","","<p>Represents run failures.\n"],["Minitest::Assertions","","Minitest/Assertions.html","","<p>Minitest Assertions.  All assertion methods accept a <code>msg</code> which is printed if the assertion fails.\n<p>Protocol: …\n"],["Minitest::BacktraceFilter","","Minitest/BacktraceFilter.html","","<p>The standard backtrace filter for minitest.\n<p>See Minitest.backtrace_filter=.\n"],["Minitest::BenchSpec","","Minitest/BenchSpec.html","","<p>The spec version of Minitest::Benchmark.\n"],["Minitest::Benchmark","","Minitest/Benchmark.html","","<p>Subclass Benchmark to create your own benchmark runs. Methods starting with “bench_” get executed …\n"],["Minitest::CompositeReporter","","Minitest/CompositeReporter.html","","<p>Dispatch to multiple reporters as one.\n"],["Minitest::Expectations","","Minitest/Expectations.html","","<p>It&#39;s where you hide your “assertions”.\n<p>Please note, because of the way that expectations …\n"],["Minitest::Guard","","Minitest/Guard.html","","<p>Provides a simple set of guards that you can use in your tests to skip execution if it is not applicable. …\n"],["Minitest::Mock","","Minitest/Mock.html","","<p>A simple and clean mock object framework.\n<p>All mock objects are an instance of Mock\n"],["Minitest::Parallel","","Minitest/Parallel.html","",""],["Minitest::Parallel::Executor","","Minitest/Parallel/Executor.html","","<p>The engine used to run multiple tests in parallel.\n"],["Minitest::Parallel::Test","","Minitest/Parallel/Test.html","",""],["Minitest::Parallel::Test::ClassMethods","","Minitest/Parallel/Test/ClassMethods.html","",""],["Minitest::PrideIO","","Minitest/PrideIO.html","","<p>Show your testing pride!\n"],["Minitest::PrideLOL","","Minitest/PrideLOL.html","","<p>If you thought the PrideIO was colorful…\n<p>(Inspired by lolcat, but with clean math)\n"],["Minitest::ProgressReporter","","Minitest/ProgressReporter.html","","<p>A very simple reporter that prints the “dots” during the run.\n<p>This is added to the top-level …\n"],["Minitest::Reportable","","Minitest/Reportable.html","","<p>Shared code for anything that can get passed to a Reporter. See Minitest::Test &amp; Minitest::Result …\n"],["Minitest::Reporter","","Minitest/Reporter.html","",""],["Minitest::Result","","Minitest/Result.html","","<p>This represents a test result in a clean way that can be marshalled over a wire. Tests can do anything …\n"],["Minitest::Runnable","","Minitest/Runnable.html","","<p>Represents anything “runnable”, like Test, Spec, Benchmark, or whatever you can dream up.\n<p>Subclasses …\n"],["Minitest::Skip","","Minitest/Skip.html","","<p>Assertion raised when skipping a run.\n"],["Minitest::Spec","","Minitest/Spec.html","","<p>Minitest::Spec – The faster, better, less-magical spec framework!\n<p>For a list of expectations, see Minitest::Expectations …\n"],["Minitest::Spec::DSL","","Minitest/Spec/DSL.html","","<p>Oh look! A Minitest::Spec::DSL module! Eat your heart out DHH.\n"],["Minitest::Spec::DSL::InstanceMethods","","Minitest/Spec/DSL/InstanceMethods.html","","<p>Rdoc… why are you so dumb?\n"],["Minitest::StatisticsReporter","","Minitest/StatisticsReporter.html","","<p>A reporter that gathers statistics about a test run. Does not do any IO because meant to be used as a …\n"],["Minitest::SummaryReporter","","Minitest/SummaryReporter.html","","<p>A reporter that prints the header, summary, and failure details at the end of the run.\n<p>This is added to …\n"],["Minitest::Test","","Minitest/Test.html","","<p>Subclass Test to create your own tests. Typically you&#39;ll want a Test subclass per implementation …\n"],["Minitest::Test::LifecycleHooks","","Minitest/Test/LifecycleHooks.html","","<p>Provides before/after hooks for setup and teardown. These are meant for library writers, NOT for regular …\n"],["Minitest::UnexpectedError","","Minitest/UnexpectedError.html","","<p>Assertion wrapping an unexpected error that was raised during a run.\n"],["Minitest::Unit","","Minitest/Unit.html","",""],["Minitest::Unit::TestCase","","Minitest/Unit/TestCase.html","",""],["MockExpectationError","","MockExpectationError.html","",""],["Module","","Module.html","",""],["Object","","Object.html","","<p>Object extensions for Minitest::Mock.\n"],["<<","Minitest::CompositeReporter","Minitest/CompositeReporter.html#method-i-3C-3C","(reporter)","<p>Add another reporter to the mix.\n"],["<<","Minitest::Parallel::Executor","Minitest/Parallel/Executor.html#method-i-3C-3C","(work;)","<p>Add a job to the queue\n"],["_","Minitest::Spec::DSL::InstanceMethods","Minitest/Spec/DSL/InstanceMethods.html#method-i-_","(value = nil, &block)","<p>Takes a value or a block and returns a value monad that has all of Expectations methods available to …\n"],["__run","Minitest","Minitest.html#method-c-__run","(reporter, options)","<p>Internal run method. Responsible for telling all Runnable sub-classes to run.\n"],["after","Minitest::Spec::DSL","Minitest/Spec/DSL.html#method-i-after","(_type = nil, &block)","<p>Define an &#39;after&#39; action. Inherits the way normal methods should.\n<p>NOTE: <code>type</code> is ignored and is …\n"],["after_run","Minitest","Minitest.html#method-c-after_run","(&block)","<p>A simple hook allowing you to run a block of code after everything is done running. Eg:\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Minitest</span>.<span class=\"ruby-identifier\">after_run</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["after_setup","Minitest::Test::LifecycleHooks","Minitest/Test/LifecycleHooks.html#method-i-after_setup","()","<p>Runs before every test, after setup. This hook is meant for libraries to extend minitest. It is not meant …\n"],["after_teardown","Minitest::Test::LifecycleHooks","Minitest/Test/LifecycleHooks.html#method-i-after_teardown","()","<p>Runs after every test, after teardown. This hook is meant for libraries to extend minitest. It is not …\n"],["assert","Minitest::Assertions","Minitest/Assertions.html#method-i-assert","(test, msg = nil)","<p>Fails unless <code>test</code> is truthy.\n"],["assert_empty","Minitest::Assertions","Minitest/Assertions.html#method-i-assert_empty","(obj, msg = nil)","<p>Fails unless <code>obj</code> is empty.\n"],["assert_equal","Minitest::Assertions","Minitest/Assertions.html#method-i-assert_equal","(exp, act, msg = nil)","<p>Fails unless <code>exp == act</code> printing the difference between the two, if possible.\n<p>If there is no visible difference …\n"],["assert_in_delta","Minitest::Assertions","Minitest/Assertions.html#method-i-assert_in_delta","(exp, act, delta = 0.001, msg = nil)","<p>For comparing Floats.  Fails unless <code>exp</code> and <code>act</code> are within <code>delta</code> of each other.\n\n<pre>assert_in_delta Math::PI, ...</pre>\n"],["assert_in_epsilon","Minitest::Assertions","Minitest/Assertions.html#method-i-assert_in_epsilon","(exp, act, epsilon = 0.001, msg = nil)","<p>For comparing Floats.  Fails unless <code>exp</code> and <code>act</code> have a relative error less than <code>epsilon</code>.\n"],["assert_includes","Minitest::Assertions","Minitest/Assertions.html#method-i-assert_includes","(collection, obj, msg = nil)","<p>Fails unless <code>collection</code> includes <code>obj</code>.\n"],["assert_instance_of","Minitest::Assertions","Minitest/Assertions.html#method-i-assert_instance_of","(cls, obj, msg = nil)","<p>Fails unless <code>obj</code> is an instance of <code>cls</code>.\n"],["assert_kind_of","Minitest::Assertions","Minitest/Assertions.html#method-i-assert_kind_of","(cls, obj, msg = nil)","<p>Fails unless <code>obj</code> is a kind of <code>cls</code>.\n"],["assert_match","Minitest::Assertions","Minitest/Assertions.html#method-i-assert_match","(matcher, obj, msg = nil)","<p>Fails unless <code>matcher</code> <code>=~</code> <code>obj</code>.\n"],["assert_mock","Minitest::Assertions","Minitest/Assertions.html#method-i-assert_mock","(mock)","<p>Assert that the mock verifies correctly.\n"],["assert_nil","Minitest::Assertions","Minitest/Assertions.html#method-i-assert_nil","(obj, msg = nil)","<p>Fails unless <code>obj</code> is nil\n"],["assert_operator","Minitest::Assertions","Minitest/Assertions.html#method-i-assert_operator","(o1, op, o2 = UNDEFINED, msg = nil)","<p>For testing with binary operators. Eg:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">assert_operator</span> <span class=\"ruby-value\">5</span>, <span class=\"ruby-value\">:&lt;=</span>, <span class=\"ruby-value\">4</span>\n</pre>\n"],["assert_output","Minitest::Assertions","Minitest/Assertions.html#method-i-assert_output","(stdout = nil, stderr = nil)","<p>Fails if stdout or stderr do not output the expected results. Pass in nil if you don&#39;t care about …\n"],["assert_path_exists","Minitest::Assertions","Minitest/Assertions.html#method-i-assert_path_exists","(path, msg = nil)","<p>Fails unless <code>path</code> exists.\n"],["assert_performance","Minitest::Benchmark","Minitest/Benchmark.html#method-i-assert_performance","(validation, &work)","<p>Runs the given <code>work</code>, gathering the times of each run. Range and times are then passed to a given <code>validation</code> …\n"],["assert_performance_constant","Minitest::Benchmark","Minitest/Benchmark.html#method-i-assert_performance_constant","(threshold = 0.99, &work)","<p>Runs the given <code>work</code> and asserts that the times gathered fit to match a constant rate (eg, linear slope …\n"],["assert_performance_exponential","Minitest::Benchmark","Minitest/Benchmark.html#method-i-assert_performance_exponential","(threshold = 0.99, &work)","<p>Runs the given <code>work</code> and asserts that the times gathered fit to match a exponential curve within a given …\n"],["assert_performance_linear","Minitest::Benchmark","Minitest/Benchmark.html#method-i-assert_performance_linear","(threshold = 0.99, &work)","<p>Runs the given <code>work</code> and asserts that the times gathered fit to match a straight line within a given error …\n"],["assert_performance_logarithmic","Minitest::Benchmark","Minitest/Benchmark.html#method-i-assert_performance_logarithmic","(threshold = 0.99, &work)","<p>Runs the given <code>work</code> and asserts that the times gathered fit to match a logarithmic curve within a given …\n"],["assert_performance_power","Minitest::Benchmark","Minitest/Benchmark.html#method-i-assert_performance_power","(threshold = 0.99, &work)","<p>Runs the given <code>work</code> and asserts that the times gathered curve fit to match a power curve within a given …\n"],["assert_predicate","Minitest::Assertions","Minitest/Assertions.html#method-i-assert_predicate","(o1, op, msg = nil)","<p>For testing with predicates. Eg:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">assert_predicate</span> <span class=\"ruby-identifier\">str</span>, <span class=\"ruby-value\">:empty?</span>\n</pre>\n<p>This is really meant for specs and is front-ended …\n"],["assert_raises","Minitest::Assertions","Minitest/Assertions.html#method-i-assert_raises","(*exp)","<p>Fails unless the block raises one of <code>exp</code>. Returns the exception matched so you can check the message, …\n"],["assert_respond_to","Minitest::Assertions","Minitest/Assertions.html#method-i-assert_respond_to","(obj, meth, msg = nil)","<p>Fails unless <code>obj</code> responds to <code>meth</code>.\n"],["assert_same","Minitest::Assertions","Minitest/Assertions.html#method-i-assert_same","(exp, act, msg = nil)","<p>Fails unless <code>exp</code> and <code>act</code> are #equal?\n"],["assert_send","Minitest::Assertions","Minitest/Assertions.html#method-i-assert_send","(send_ary, m = nil)","<p><code>send_ary</code> is a receiver, message and arguments.\n<p>Fails unless the call returns a true value\n"],["assert_silent","Minitest::Assertions","Minitest/Assertions.html#method-i-assert_silent","()","<p>Fails if the block outputs anything to stderr or stdout.\n<p>See also: #assert_output\n"],["assert_throws","Minitest::Assertions","Minitest/Assertions.html#method-i-assert_throws","(sym, msg = nil)","<p>Fails unless the block throws <code>sym</code>\n"],["autorun","Minitest","Minitest.html#method-c-autorun","()","<p>Registers Minitest to run at process exit\n"],["before","Minitest::Spec::DSL","Minitest/Spec/DSL.html#method-i-before","(_type = nil, &block)","<p>Define a &#39;before&#39; action. Inherits the way normal methods should.\n<p>NOTE: <code>type</code> is ignored and is …\n"],["before_setup","Minitest::Test::LifecycleHooks","Minitest/Test/LifecycleHooks.html#method-i-before_setup","()","<p>Runs before every test, before setup. This hook is meant for libraries to extend minitest. It is not …\n"],["before_teardown","Minitest::Test::LifecycleHooks","Minitest/Test/LifecycleHooks.html#method-i-before_teardown","()","<p>Runs after every test, before teardown. This hook is meant for libraries to extend minitest. It is not …\n"],["bench","Minitest::BenchSpec","Minitest/BenchSpec.html#method-c-bench","(name, &block)","<p>This is used to define a new benchmark method. You usually don&#39;t use this directly and is intended …\n"],["bench_exp","Minitest::Benchmark","Minitest/Benchmark.html#method-c-bench_exp","(min, max, base = 10)","<p>Returns a set of ranges stepped exponentially from <code>min</code> to <code>max</code> by powers of <code>base</code>. Eg:\n\n<pre>bench_exp(2, 16, ...</pre>\n"],["bench_linear","Minitest::Benchmark","Minitest/Benchmark.html#method-c-bench_linear","(min, max, step = 10)","<p>Returns a set of ranges stepped linearly from <code>min</code> to <code>max</code> by <code>step</code>. Eg:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">bench_linear</span>(<span class=\"ruby-value\">20</span>, <span class=\"ruby-value\">40</span>, <span class=\"ruby-value\">10</span>) <span class=\"ruby-comment\"># =&gt; [20, ...</span>\n</pre>\n"],["bench_performance_constant","Minitest::BenchSpec","Minitest/BenchSpec.html#method-c-bench_performance_constant","(name, threshold = 0.99, &work)","<p>Create a benchmark that verifies that the performance is constant.\n\n<pre>describe &quot;my class Bench&quot; do\n  bench_performance_constant ...</pre>\n"],["bench_performance_exponential","Minitest::BenchSpec","Minitest/BenchSpec.html#method-c-bench_performance_exponential","(name, threshold = 0.99, &work)","<p>Create a benchmark that verifies that the performance is exponential.\n\n<pre>describe &quot;my class Bench&quot; do\n  bench_performance_exponential ...</pre>\n"],["bench_performance_linear","Minitest::BenchSpec","Minitest/BenchSpec.html#method-c-bench_performance_linear","(name, threshold = 0.99, &work)","<p>Create a benchmark that verifies that the performance is linear.\n\n<pre>describe &quot;my class Bench&quot; do\n  bench_performance_linear ...</pre>\n"],["bench_performance_logarithmic","Minitest::BenchSpec","Minitest/BenchSpec.html#method-c-bench_performance_logarithmic","(name, threshold = 0.99, &work)","<p>Create a benchmark that verifies that the performance is logarithmic.\n\n<pre>describe &quot;my class Bench&quot; do\n  bench_performance_logarithmic ...</pre>\n"],["bench_performance_power","Minitest::BenchSpec","Minitest/BenchSpec.html#method-c-bench_performance_power","(name, threshold = 0.99, &work)","<p>Create a benchmark that verifies that the performance is power.\n\n<pre>describe &quot;my class Bench&quot; do\n  bench_performance_power ...</pre>\n"],["bench_range","Minitest::BenchSpec","Minitest/BenchSpec.html#method-c-bench_range","(&block)","<p>Specifies the ranges used for benchmarking for that class.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">bench_range</span> <span class=\"ruby-keyword\">do</span>\n  <span class=\"ruby-identifier\">bench_exp</span>(<span class=\"ruby-value\">2</span>, <span class=\"ruby-value\">16</span>, <span class=\"ruby-value\">2</span>)\n<span class=\"ruby-keyword\">end</span>\n</pre>\n<p>See …\n"],["bench_range","Minitest::Benchmark","Minitest/Benchmark.html#method-c-bench_range","()","<p>Specifies the ranges used for benchmarking for that class. Defaults to exponential growth from 1 to 10k …\n"],["binary_string","Minitest::SummaryReporter","Minitest/SummaryReporter.html#method-i-binary_string","()",""],["capture_io","Minitest::Assertions","Minitest/Assertions.html#method-i-capture_io","()","<p>Captures $stdout and $stderr into strings:\n\n<pre>out, err = capture_io do\n  puts &quot;Some info&quot;\n  warn &quot;You did ...</pre>\n"],["capture_subprocess_io","Minitest::Assertions","Minitest/Assertions.html#method-i-capture_subprocess_io","()","<p>Captures $stdout and $stderr into strings, using Tempfile to ensure that subprocess IO is captured as …\n"],["describe","Kernel","Kernel.html#method-i-describe","(desc, *additional_desc, &block)","<p>Describe a series of expectations for a given target <code>desc</code>.\n<p>Defines a test class subclassing from either …\n"],["diff","Minitest::Assertions","Minitest/Assertions.html#method-c-diff","()","<p>Returns the diff command to use in #diff. Tries to intelligently figure out what diff to use.\n"],["diff","Minitest::Assertions","Minitest/Assertions.html#method-i-diff","(exp, act)","<p>Returns a diff between <code>exp</code> and <code>act</code>. If there is no known diff command or if it doesn&#39;t make sense …\n"],["diff=","Minitest::Assertions","Minitest/Assertions.html#method-c-diff-3D","(o)","<p>Set the diff command to use in #diff.\n"],["error?","Minitest::Reportable","Minitest/Reportable.html#method-i-error-3F","()","<p>Did this run error?\n"],["exception_details","Minitest::Assertions","Minitest/Assertions.html#method-i-exception_details","(e, msg)","<p>Returns details for exception <code>e</code>\n"],["expect","Minitest::Mock","Minitest/Mock.html#method-i-expect","(name, retval, args = [], &blk)","<p>Expect that method <code>name</code> is called, optionally with <code>args</code> or a <code>blk</code>, and returns <code>retval</code>.\n\n<pre>@mock.expect(:meaning_of_life, ...</pre>\n"],["expect","Minitest::Spec::DSL::InstanceMethods","Minitest/Spec/DSL/InstanceMethods.html#method-i-expect","(value = nil, &block)",""],["fail_after","Minitest::Assertions","Minitest/Assertions.html#method-i-fail_after","(y,m,d,msg)","<p>Fails after a given date (in the local time zone). This allows you to put time-bombs in your tests if …\n"],["filter","Minitest::BacktraceFilter","Minitest/BacktraceFilter.html#method-i-filter","(bt)","<p>Filter <code>bt</code> to something useful. Returns the whole thing if $DEBUG.\n"],["fit_error","Minitest::Benchmark","Minitest/Benchmark.html#method-i-fit_error","(xys)","<p>Takes an array of x/y pairs and calculates the general R^2 value.\n<p>See: en.wikipedia.org/wiki/Coefficient_of_determination …\n"],["fit_exponential","Minitest::Benchmark","Minitest/Benchmark.html#method-i-fit_exponential","(xs, ys)","<p>To fit a functional form: y = ae^(bx).\n<p>Takes x and y values and returns [a, b, r^2].\n<p>See: mathworld.wolfram.com/LeastSquaresFittingExponential.html …\n"],["fit_linear","Minitest::Benchmark","Minitest/Benchmark.html#method-i-fit_linear","(xs, ys)","<p>Fits the functional form: a + bx.\n<p>Takes x and y values and returns [a, b, r^2].\n<p>See: mathworld.wolfram.com/LeastSquaresFitting.html …\n"],["fit_logarithmic","Minitest::Benchmark","Minitest/Benchmark.html#method-i-fit_logarithmic","(xs, ys)","<p>To fit a functional form: y = a + b*ln(x).\n<p>Takes x and y values and returns [a, b, r^2].\n<p>See: mathworld.wolfram.com/LeastSquaresFittingLogarithmic.html …\n"],["fit_power","Minitest::Benchmark","Minitest/Benchmark.html#method-i-fit_power","(xs, ys)","<p>To fit a functional form: y = ax^b.\n<p>Takes x and y values and returns [a, b, r^2].\n<p>See: mathworld.wolfram.com/LeastSquaresFittingPowerLaw.html …\n"],["flunk","Minitest::Assertions","Minitest/Assertions.html#method-i-flunk","(msg = nil)","<p>Fails with <code>msg</code>.\n"],["from","Minitest::Result","Minitest/Result.html#method-c-from","(runnable)","<p>Create a new test result from a Runnable instance.\n"],["i_suck_and_my_tests_are_order_dependent!","Minitest::Test","Minitest/Test.html#method-c-i_suck_and_my_tests_are_order_dependent-21","()","<p>Call this at the top of your tests when you absolutely positively need to have ordered tests. In doing …\n"],["it","Minitest::Spec::DSL","Minitest/Spec/DSL.html#method-i-it","(desc = \"anonymous\", &block)","<p>Define an expectation with name <code>desc</code>. Name gets morphed to a proper test method name. For some freakish …\n"],["jruby?","Minitest::Guard","Minitest/Guard.html#method-i-jruby-3F","(platform = RUBY_PLATFORM)","<p>Is this running on jruby?\n"],["let","Minitest::Spec::DSL","Minitest/Spec/DSL.html#method-i-let","(name, &block)","<p>Essentially, define an accessor for <code>name</code> with <code>block</code>.\n<p>Why use let instead of def? I honestly don&#39;t …\n"],["location","Minitest::Assertion","Minitest/Assertion.html#method-i-location","()","<p>Where was this run before an assertion was raised?\n"],["location","Minitest::Reportable","Minitest/Reportable.html#method-i-location","()","<p>The location identifier of this test. Depends on a method existing called class_name.\n"],["maglev?","Minitest::Guard","Minitest/Guard.html#method-i-maglev-3F","(platform = defined?(RUBY_ENGINE) && RUBY_ENGINE)","<p>Is this running on maglev?\n"],["make_my_diffs_pretty!","Minitest::Test","Minitest/Test.html#method-c-make_my_diffs_pretty-21","()","<p>Make diffs for this Test use #pretty_inspect so that diff in assert_equal can have more details. NOTE: …\n"],["message","Minitest::Assertions","Minitest/Assertions.html#method-i-message","(msg = nil, ending = nil, &default)","<p>Returns a proc that will output <code>msg</code> along with the default message.\n"],["methods_matching","Minitest::Runnable","Minitest/Runnable.html#method-c-methods_matching","(re)","<p>Returns all instance methods matching the pattern <code>re</code>.\n"],["mri?","Minitest::Guard","Minitest/Guard.html#method-i-mri-3F","(platform = RUBY_DESCRIPTION)","<p>Is this running on mri?\n"],["mu_pp","Minitest::Assertions","Minitest/Assertions.html#method-i-mu_pp","(obj)","<p>This returns a human-readable version of <code>obj</code>. By default #inspect is called. You can override this to …\n"],["mu_pp_for_diff","Minitest::Assertions","Minitest/Assertions.html#method-i-mu_pp_for_diff","(obj)","<p>This returns a diff-able more human-readable version of <code>obj</code>. This differs from the regular mu_pp because …\n"],["must_be","Minitest::Expectations","Minitest/Expectations.html#method-i-must_be","","<p>See Minitest::Assertions#assert_operator\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">n</span>.<span class=\"ruby-identifier\">must_be</span> <span class=\"ruby-value\">:&lt;=</span>, <span class=\"ruby-value\">42</span>\n</pre>\n<p>This can also do predicates:\n"],["must_be_close_to","Minitest::Expectations","Minitest/Expectations.html#method-i-must_be_close_to","","<p>See Minitest::Assertions#assert_in_delta\n\n<pre>n.must_be_close_to m [, delta]</pre>\n"],["must_be_empty","Minitest::Expectations","Minitest/Expectations.html#method-i-must_be_empty","","<p>See Minitest::Assertions#assert_empty.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">collection</span>.<span class=\"ruby-identifier\">must_be_empty</span>\n</pre>\n"],["must_be_instance_of","Minitest::Expectations","Minitest/Expectations.html#method-i-must_be_instance_of","","<p>See Minitest::Assertions#assert_instance_of\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">obj</span>.<span class=\"ruby-identifier\">must_be_instance_of</span> <span class=\"ruby-identifier\">klass</span>\n</pre>\n"],["must_be_kind_of","Minitest::Expectations","Minitest/Expectations.html#method-i-must_be_kind_of","","<p>See Minitest::Assertions#assert_kind_of\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">obj</span>.<span class=\"ruby-identifier\">must_be_kind_of</span> <span class=\"ruby-identifier\">mod</span>\n</pre>\n"],["must_be_nil","Minitest::Expectations","Minitest/Expectations.html#method-i-must_be_nil","","<p>See Minitest::Assertions#assert_nil\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">obj</span>.<span class=\"ruby-identifier\">must_be_nil</span>\n</pre>\n"],["must_be_same_as","Minitest::Expectations","Minitest/Expectations.html#method-i-must_be_same_as","","<p>See Minitest::Assertions#assert_same\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">a</span>.<span class=\"ruby-identifier\">must_be_same_as</span> <span class=\"ruby-identifier\">b</span>\n</pre>\n"],["must_be_silent","Minitest::Expectations","Minitest/Expectations.html#method-i-must_be_silent","","<p>See Minitest::Assertions#assert_silent\n\n<pre>proc { ... }.must_be_silent</pre>\n"],["must_be_within_epsilon","Minitest::Expectations","Minitest/Expectations.html#method-i-must_be_within_epsilon","","<p>See Minitest::Assertions#assert_in_epsilon\n\n<pre>n.must_be_within_epsilon m [, epsilon]</pre>\n"],["must_equal","Minitest::Expectations","Minitest/Expectations.html#method-i-must_equal","","<p>See Minitest::Assertions#assert_equal\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">a</span>.<span class=\"ruby-identifier\">must_equal</span> <span class=\"ruby-identifier\">b</span>\n</pre>\n"],["must_include","Minitest::Expectations","Minitest/Expectations.html#method-i-must_include","","<p>See Minitest::Assertions#assert_includes\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">collection</span>.<span class=\"ruby-identifier\">must_include</span> <span class=\"ruby-identifier\">obj</span>\n</pre>\n"],["must_match","Minitest::Expectations","Minitest/Expectations.html#method-i-must_match","","<p>See Minitest::Assertions#assert_match\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">a</span>.<span class=\"ruby-identifier\">must_match</span> <span class=\"ruby-identifier\">b</span>\n</pre>\n"],["must_output","Minitest::Expectations","Minitest/Expectations.html#method-i-must_output","","<p>See Minitest::Assertions#assert_output\n\n<pre>proc { ... }.must_output out_or_nil [, err]</pre>\n"],["must_raise","Minitest::Expectations","Minitest/Expectations.html#method-i-must_raise","","<p>See Minitest::Assertions#assert_raises\n\n<pre>proc { ... }.must_raise exception</pre>\n"],["must_respond_to","Minitest::Expectations","Minitest/Expectations.html#method-i-must_respond_to","","<p>See Minitest::Assertions#assert_respond_to\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">obj</span>.<span class=\"ruby-identifier\">must_respond_to</span> <span class=\"ruby-identifier\">msg</span>\n</pre>\n"],["must_throw","Minitest::Expectations","Minitest/Expectations.html#method-i-must_throw","","<p>See Minitest::Assertions#assert_throws\n\n<pre>proc { ... }.must_throw sym</pre>\n"],["name","Minitest::Runnable","Minitest/Runnable.html#method-i-name","()","<p>Name of the run.\n"],["name=","Minitest::Runnable","Minitest/Runnable.html#method-i-name-3D","(o)","<p>Set the name of the run.\n"],["new","Minitest::Parallel::Executor","Minitest/Parallel/Executor.html#method-c-new","(size)","<p>Create a parallel test executor of with <code>size</code> workers.\n"],["osx?","Minitest::Guard","Minitest/Guard.html#method-i-osx-3F","(platform = RUBY_PLATFORM)","<p>Is this running on macOS?\n"],["parallelize_me!","Minitest::Test","Minitest/Test.html#method-c-parallelize_me-21","()","<p>Call this at the top of your tests when you want to run your tests in parallel. In doing so, you&#39;re …\n"],["pass","Minitest::Assertions","Minitest/Assertions.html#method-i-pass","(_msg = nil)","<p>used for counting assertions\n"],["passed?","Minitest::AbstractReporter","Minitest/AbstractReporter.html#method-i-passed-3F","()","<p>Did this run pass?\n"],["passed?","Minitest::Reportable","Minitest/Reportable.html#method-i-passed-3F","()","<p>Did this run pass?\n<p>Note: skipped runs are not considered passing, but they don&#39;t cause the process …\n"],["passed?","Minitest::Runnable","Minitest/Runnable.html#method-i-passed-3F","()","<p>Did this run pass?\n<p>Note: skipped runs are not considered passing, but they don&#39;t cause the process …\n"],["path_must_exist","Minitest::Expectations","Minitest/Expectations.html#method-i-path_must_exist","","<p>See Minitest::Assertions#assert_path_exists\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">_</span>(<span class=\"ruby-identifier\">some_path</span>).<span class=\"ruby-identifier\">path_must_exist</span>\n</pre>\n"],["path_wont_exist","Minitest::Expectations","Minitest/Expectations.html#method-i-path_wont_exist","","<p>See Minitest::Assertions#refute_path_exists\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">_</span>(<span class=\"ruby-identifier\">some_path</span>).<span class=\"ruby-identifier\">path_wont_exist</span>\n</pre>\n"],["prerecord","Minitest::AbstractReporter","Minitest/AbstractReporter.html#method-i-prerecord","(klass, name)","<p>About to start running a test. This allows a reporter to show that it is starting or that we are in the …\n"],["pride","Minitest::PrideIO","Minitest/PrideIO.html#method-i-pride","(string)","<p>Color a string.\n"],["pride","Minitest::PrideLOL","Minitest/PrideLOL.html#method-i-pride","(string)","<p>Make the string even more colorful. Damnit.\n"],["pride!","Minitest::PrideIO","Minitest/PrideIO.html#method-c-pride-21","()","<p>Activate the pride plugin. Called from both -p option and minitest/pride\n"],["pride?","Minitest::PrideIO","Minitest/PrideIO.html#method-c-pride-3F","()","<p>Are we showing our testing pride?\n"],["print","Minitest::PrideIO","Minitest/PrideIO.html#method-i-print","(o)","<p>Wrap print to colorize the output.\n"],["record","Minitest::AbstractReporter","Minitest/AbstractReporter.html#method-i-record","(result)","<p>Output and record the result of the test. Call result#result_code to get the result character string. …\n"],["refute","Minitest::Assertions","Minitest/Assertions.html#method-i-refute","(test, msg = nil)","<p>Fails if <code>test</code> is truthy.\n"],["refute_empty","Minitest::Assertions","Minitest/Assertions.html#method-i-refute_empty","(obj, msg = nil)","<p>Fails if <code>obj</code> is empty.\n"],["refute_equal","Minitest::Assertions","Minitest/Assertions.html#method-i-refute_equal","(exp, act, msg = nil)","<p>Fails if <code>exp == act</code>.\n<p>For floats use refute_in_delta.\n"],["refute_in_delta","Minitest::Assertions","Minitest/Assertions.html#method-i-refute_in_delta","(exp, act, delta = 0.001, msg = nil)","<p>For comparing Floats.  Fails if <code>exp</code> is within <code>delta</code> of <code>act</code>.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">refute_in_delta</span> <span class=\"ruby-constant\">Math</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">PI</span>, (<span class=\"ruby-value\">22.0</span> <span class=\"ruby-operator\">/</span> <span class=\"ruby-value\">7.0</span>)\n</pre>\n"],["refute_in_epsilon","Minitest::Assertions","Minitest/Assertions.html#method-i-refute_in_epsilon","(a, b, epsilon = 0.001, msg = nil)","<p>For comparing Floats.  Fails if <code>exp</code> and <code>act</code> have a relative error less than <code>epsilon</code>.\n"],["refute_includes","Minitest::Assertions","Minitest/Assertions.html#method-i-refute_includes","(collection, obj, msg = nil)","<p>Fails if <code>collection</code> includes <code>obj</code>.\n"],["refute_instance_of","Minitest::Assertions","Minitest/Assertions.html#method-i-refute_instance_of","(cls, obj, msg = nil)","<p>Fails if <code>obj</code> is an instance of <code>cls</code>.\n"],["refute_kind_of","Minitest::Assertions","Minitest/Assertions.html#method-i-refute_kind_of","(cls, obj, msg = nil)","<p>Fails if <code>obj</code> is a kind of <code>cls</code>.\n"],["refute_match","Minitest::Assertions","Minitest/Assertions.html#method-i-refute_match","(matcher, obj, msg = nil)","<p>Fails if <code>matcher</code> <code>=~</code> <code>obj</code>.\n"],["refute_nil","Minitest::Assertions","Minitest/Assertions.html#method-i-refute_nil","(obj, msg = nil)","<p>Fails if <code>obj</code> is nil.\n"],["refute_operator","Minitest::Assertions","Minitest/Assertions.html#method-i-refute_operator","(o1, op, o2 = UNDEFINED, msg = nil)","<p>Fails if <code>o1</code> is not <code>op</code> <code>o2</code>. Eg:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">refute_operator</span> <span class=\"ruby-value\">1</span>, <span class=\"ruby-value\">:&gt;</span>, <span class=\"ruby-value\">2</span> <span class=\"ruby-comment\">#=&gt; pass</span>\n<span class=\"ruby-identifier\">refute_operator</span> <span class=\"ruby-value\">1</span>, <span class=\"ruby-value\">:&lt;</span>, <span class=\"ruby-value\">2</span> <span class=\"ruby-comment\">#=&gt; fail</span>\n</pre>\n"],["refute_path_exists","Minitest::Assertions","Minitest/Assertions.html#method-i-refute_path_exists","(path, msg = nil)","<p>Fails if <code>path</code> exists.\n"],["refute_predicate","Minitest::Assertions","Minitest/Assertions.html#method-i-refute_predicate","(o1, op, msg = nil)","<p>For testing with predicates.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">refute_predicate</span> <span class=\"ruby-identifier\">str</span>, <span class=\"ruby-value\">:empty?</span>\n</pre>\n<p>This is really meant for specs and is front-ended …\n"],["refute_respond_to","Minitest::Assertions","Minitest/Assertions.html#method-i-refute_respond_to","(obj, meth, msg = nil)","<p>Fails if <code>obj</code> responds to the message <code>meth</code>.\n"],["refute_same","Minitest::Assertions","Minitest/Assertions.html#method-i-refute_same","(exp, act, msg = nil)","<p>Fails if <code>exp</code> is the same (by object identity) as <code>act</code>.\n"],["register_spec_type","Minitest::Spec::DSL","Minitest/Spec/DSL.html#method-i-register_spec_type","(*args, &block)","<p>Register a new type of spec that matches the spec&#39;s description. This method can take either a Regexp …\n"],["report","Minitest::AbstractReporter","Minitest/AbstractReporter.html#method-i-report","()","<p>Outputs the summary of the run.\n"],["report","Minitest::StatisticsReporter","Minitest/StatisticsReporter.html#method-i-report","()","<p>Report on the tracked statistics.\n"],["result_code","Minitest::Reportable","Minitest/Reportable.html#method-i-result_code","()","<p>Returns “.”, “F”, or “E” based on the result of the run.\n"],["result_code","Minitest::Runnable","Minitest/Runnable.html#method-i-result_code","()","<p>Returns a single character string to print based on the result of the run. One of <code>&quot;.&quot;</code>, <code>&quot;F&quot;</code> …\n"],["rubinius?","Minitest::Guard","Minitest/Guard.html#method-i-rubinius-3F","(platform = defined?(RUBY_ENGINE) && RUBY_ENGINE)","<p>Is this running on rubinius?\n"],["run","Minitest","Minitest.html#method-c-run","(args = [])","<p>This is the top-level run method. Everything starts from here. It tells each Runnable sub-class to run, …\n"],["run","Minitest::Runnable","Minitest/Runnable.html#method-i-run","()","<p>Runs a single method. Needs to return self.\n"],["run","Minitest::Runnable","Minitest/Runnable.html#method-c-run","(reporter, options = {})","<p>Responsible for running all runnable methods in a given class, each in its own instance. Each instance …\n"],["run","Minitest::Test","Minitest/Test.html#method-i-run","()","<p>Runs a single test with setup/teardown hooks.\n"],["run_one_method","Minitest::Runnable","Minitest/Runnable.html#method-c-run_one_method","(klass, method_name, reporter)","<p>Runs a single method and has the reporter record the result. This was considered internal API but is …\n"],["runnable_methods","Minitest::Runnable","Minitest/Runnable.html#method-c-runnable_methods","()","<p>Each subclass of Runnable is responsible for overriding this method to return all runnable methods.  …\n"],["runnable_methods","Minitest::Test","Minitest/Test.html#method-c-runnable_methods","()","<p>Returns all instance methods starting with “test_”. Based on #test_order, the methods are either …\n"],["runnables","Minitest::Runnable","Minitest/Runnable.html#method-c-runnables","()","<p>Returns all subclasses of Runnable.\n"],["setup","Minitest::Test::LifecycleHooks","Minitest/Test/LifecycleHooks.html#method-i-setup","()","<p>Runs before every test. Use this to set up before each test run.\n"],["shutdown","Minitest::Parallel::Executor","Minitest/Parallel/Executor.html#method-i-shutdown","()","<p>Shuts down the pool of workers by signalling them to quit and waiting for them all to finish what they&#39;re …\n"],["sigma","Minitest::Benchmark","Minitest/Benchmark.html#method-i-sigma","(enum, &block)","<p>Enumerates over <code>enum</code> mapping <code>block</code> if given, returning the sum of the result. Eg:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">sigma</span>([<span class=\"ruby-value\">1</span>, <span class=\"ruby-value\">2</span>, <span class=\"ruby-value\">3</span>])    <span class=\"ruby-operator\">...</span>\n</pre>\n"],["skip","Minitest::Assertions","Minitest/Assertions.html#method-i-skip","(msg = nil, bt = caller)","<p>Skips the current run. If run in verbose-mode, the skipped run gets listed at the end of the run but …\n"],["skip_until","Minitest::Assertions","Minitest/Assertions.html#method-i-skip_until","(y,m,d,msg)","<p>Skips the current run until a given date (in the local time zone). This allows you to put some fixes …\n"],["skipped?","Minitest::Assertions","Minitest/Assertions.html#method-i-skipped-3F","()","<p>Was this testcase skipped? Meant for #teardown.\n"],["skipped?","Minitest::Reportable","Minitest/Reportable.html#method-i-skipped-3F","()","<p>Was this run skipped?\n"],["skipped?","Minitest::Runnable","Minitest/Runnable.html#method-i-skipped-3F","()","<p>Was this run skipped? See #passed? for more information.\n"],["spec_type","Minitest::Spec::DSL","Minitest/Spec/DSL.html#method-i-spec_type","(desc, *additional)","<p>Figure out the spec class to use based on a spec&#39;s description. Eg:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">spec_type</span>(<span class=\"ruby-string\">&quot;BlahController&quot;</span>) <span class=\"ruby-comment\"># ...</span>\n</pre>\n"],["specify","Minitest::Spec::DSL","Minitest/Spec/DSL.html#method-i-specify","(desc = \"anonymous\", &block)",""],["start","Minitest::AbstractReporter","Minitest/AbstractReporter.html#method-i-start","()","<p>Starts reporting on the run.\n"],["start","Minitest::Parallel::Executor","Minitest/Parallel/Executor.html#method-i-start","()","<p>Start the executor\n"],["stub","Object","Object.html#method-i-stub","(name, val_or_callable, *block_args)","<p>Add a temporary stubbed method replacing <code>name</code> for the duration of the <code>block</code>. If <code>val_or_callable</code> responds …\n"],["subject","Minitest::Spec::DSL","Minitest/Spec/DSL.html#method-i-subject","(&block)","<p>Another lazy man&#39;s accessor generator. Made even more lazy by setting the name for you to <code>subject</code> …\n"],["teardown","Minitest::Test::LifecycleHooks","Minitest/Test/LifecycleHooks.html#method-i-teardown","()","<p>Runs after every test. Use this to clean up after each test run.\n"],["test_order","Minitest::Test","Minitest/Test.html#method-c-test_order","()","<p>Defines the order to run tests (:random by default). Override this or use a convenience method to change …\n"],["things_to_diff","Minitest::Assertions","Minitest/Assertions.html#method-i-things_to_diff","(exp, act)","<p>Returns things to diff [expect, butwas], or [nil, nil] if nothing to diff.\n<p>Criterion:\n<p>Strings include newlines …\n"],["unknown","Minitest","Minitest.html#method-i-unknown","","<p>Parallel test executor\n"],["validation_for_fit","Minitest::Benchmark","Minitest/Benchmark.html#method-i-validation_for_fit","(msg, threshold)","<p>Returns a proc that calls the specified fit method and asserts that the error is within a tolerable threshold. …\n"],["value","Minitest::Spec::DSL::InstanceMethods","Minitest/Spec/DSL/InstanceMethods.html#method-i-value","(value = nil, &block)",""],["verify","Minitest::Mock","Minitest/Mock.html#method-i-verify","()","<p>Verify that all methods were called as expected. Raises <code>MockExpectationError</code> if the mock object was not …\n"],["windows?","Minitest::Guard","Minitest/Guard.html#method-i-windows-3F","(platform = RUBY_PLATFORM)","<p>Is this running on windows?\n"],["wont_be","Minitest::Expectations","Minitest/Expectations.html#method-i-wont_be","","<p>See Minitest::Assertions#refute_operator\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">n</span>.<span class=\"ruby-identifier\">wont_be</span> <span class=\"ruby-value\">:&lt;=</span>, <span class=\"ruby-value\">42</span>\n</pre>\n<p>This can also do predicates:\n"],["wont_be_close_to","Minitest::Expectations","Minitest/Expectations.html#method-i-wont_be_close_to","","<p>See Minitest::Assertions#refute_in_delta\n\n<pre>n.wont_be_close_to m [, delta]</pre>\n"],["wont_be_empty","Minitest::Expectations","Minitest/Expectations.html#method-i-wont_be_empty","","<p>See Minitest::Assertions#refute_empty\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">collection</span>.<span class=\"ruby-identifier\">wont_be_empty</span>\n</pre>\n"],["wont_be_instance_of","Minitest::Expectations","Minitest/Expectations.html#method-i-wont_be_instance_of","","<p>See Minitest::Assertions#refute_instance_of\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">obj</span>.<span class=\"ruby-identifier\">wont_be_instance_of</span> <span class=\"ruby-identifier\">klass</span>\n</pre>\n"],["wont_be_kind_of","Minitest::Expectations","Minitest/Expectations.html#method-i-wont_be_kind_of","","<p>See Minitest::Assertions#refute_kind_of\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">obj</span>.<span class=\"ruby-identifier\">wont_be_kind_of</span> <span class=\"ruby-identifier\">mod</span>\n</pre>\n"],["wont_be_nil","Minitest::Expectations","Minitest/Expectations.html#method-i-wont_be_nil","","<p>See Minitest::Assertions#refute_nil\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">obj</span>.<span class=\"ruby-identifier\">wont_be_nil</span>\n</pre>\n"],["wont_be_same_as","Minitest::Expectations","Minitest/Expectations.html#method-i-wont_be_same_as","","<p>See Minitest::Assertions#refute_same\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">a</span>.<span class=\"ruby-identifier\">wont_be_same_as</span> <span class=\"ruby-identifier\">b</span>\n</pre>\n"],["wont_be_within_epsilon","Minitest::Expectations","Minitest/Expectations.html#method-i-wont_be_within_epsilon","","<p>See Minitest::Assertions#refute_in_epsilon\n\n<pre>n.wont_be_within_epsilon m [, epsilon]</pre>\n"],["wont_equal","Minitest::Expectations","Minitest/Expectations.html#method-i-wont_equal","","<p>See Minitest::Assertions#refute_equal\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">a</span>.<span class=\"ruby-identifier\">wont_equal</span> <span class=\"ruby-identifier\">b</span>\n</pre>\n"],["wont_include","Minitest::Expectations","Minitest/Expectations.html#method-i-wont_include","","<p>See Minitest::Assertions#refute_includes\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">collection</span>.<span class=\"ruby-identifier\">wont_include</span> <span class=\"ruby-identifier\">obj</span>\n</pre>\n"],["wont_match","Minitest::Expectations","Minitest/Expectations.html#method-i-wont_match","","<p>See Minitest::Assertions#refute_match\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">a</span>.<span class=\"ruby-identifier\">wont_match</span> <span class=\"ruby-identifier\">b</span>\n</pre>\n"],["wont_respond_to","Minitest::Expectations","Minitest/Expectations.html#method-i-wont_respond_to","","<p>See Minitest::Assertions#refute_respond_to\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">obj</span>.<span class=\"ruby-identifier\">wont_respond_to</span> <span class=\"ruby-identifier\">msg</span>\n</pre>\n"],["History","","History_rdoc.html","","<p>5.14.0 / 2020-01-11\n<p>2 minor enhancements:\n<p>Block-assertions (eg assert_output) now error if raised inside …\n"],["Manifest","","Manifest_txt.html","","<p>.autotest History.rdoc Manifest.txt README.rdoc Rakefile design_rationale.rb lib/hoe/minitest.rb lib/minitest.rb …\n"],["README","","README_rdoc.html","","<p>minitest/{test,spec,mock,benchmark}\n<p>home  &mdash; github.com/seattlerb/minitest\n<p>bugs  &mdash; github.com/seattlerb/minitest/issues …\n"]]}}