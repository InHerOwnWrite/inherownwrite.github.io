var search_data = {"index":{"searchIndex":["array","float","integer","object","rexml","attlistdecl","attribute","attributes","cdata","child","comment","dtd","attlistdecl","elementdecl","entitydecl","notationdecl","parser","declaration","doctype","document","element","elementdecl","elements","encoding","entity","entityconst","externalentity","formatters","default","pretty","transitive","functions","iosource","instruction","light","node","namespace","node","notationdecl","output","parent","parseexception","parsers","baseparser","lightparser","pullevent","pullparser","sax2parser","streamparser","treeparser","ultralightparser","xpathparser","quickpath","sax2listener","security","source","sourcefactory","streamlistener","text","undefinednamespaceexception","validation","choice","event","interleave","oneormore","optional","ref","relaxng","sequence","state","validationexception","validator","zeroormore","xmldecl","xmltokens","xpath","xpathnode","xpathparser","symbol","<<()","<<()","<<()","<<()","<<()","<<()","<<()","<<()","<<()","<=>()","<=>()","==()","==()","==()","==()","==()","=~()","additiveexpr()","andexpr()","equalityexpr()","filterexpr()","functioncall()","locationpath()","multiplicativeexpr()","nodetest()","orexpr()","pathexpr()","predicate()","primaryexpr()","relationalexpr()","relativelocationpath()","unaryexpr()","unionexpr()","[]()","[]()","[]()","[]()","[]()","[]()","[]()","[]=()","[]=()","[]=()","[]=()","[]=()","__to_xpath_helper()","abbreviate()","add()","add()","add()","add()","add()","add()","add_attribute()","add_attributes()","add_element()","add_element()","add_event_to_arry()","add_event_to_arry()","add_listener()","add_listener()","add_listener()","add_listener()","add_listener()","add_listener()","add_listener()","add_namespace()","add_text()","attlistdecl()","attlistdecl()","attlistdecl?()","attribute()","attribute()","attribute_of()","attributes_of()","axe()","boolean()","build()","bytes()","cdata()","cdata()","cdata?()","cdatas()","ceiling()","characters()","check()","child()","children()","children()","clear_cache()","clone()","clone()","clone()","clone()","clone()","clone()","clone()","clone()","clone()","collect()","comment()","comment()","comment?()","comments()","compare()","compare_language()","concat()","consume()","consume()","contains()","content()","context()","context()","context=()","count()","create_from()","current_line()","current_line()","dclone()","dclone()","dclone()","dclone()","dclone()","deafen()","decode()","deep_clone()","default()","delete()","delete()","delete()","delete_all()","delete_all()","delete_at()","delete_attribute()","delete_element()","delete_if()","delete_namespace()","descendant()","descendant_recursive()","detect_encoding()","doctype()","doctype()","doctype()","doctype()","doctype()","doctype?()","doctype_end()","document()","document()","document()","done?()","dowrite()","dump()","each()","each()","each()","each()","each()","each()","each()","each()","each_attribute()","each_child()","each_element()","each_element_with_attribute()","each_element_with_text()","each_index()","each_recursive()","each_unnode()","each_with_something()","element=()","elementdecl()","elementdecl()","elementdecl?()","empty?()","empty?()","empty?()","empty?()","empty?()","encode()","encoding()","encoding=()","encoding=()","encoding=()","encoding_updated()","encoding_updated()","end_document()","end_element()","end_element?()","end_prefix_mapping()","enter()","entity()","entity()","entity()","entity?()","entity_expansion_limit()","entity_expansion_limit()","entity_expansion_limit=()","entity_expansion_limit=()","entity_expansion_text_limit()","entity_expansion_text_limit()","entity_expansion_text_limit=()","entity_expansion_text_limit=()","entitydecl()","entitydecl()","entitydecl?()","equality_relational_compare()","error?()","evaluate_predicate()","event_type()","expand()","expand()","expand_ref_in()","expanded_name()","expected()","expected()","expected()","expected()","expected()","expected()","expr()","false()","filter()","filter_nodeset()","find_encoding()","find_first_recursive()","first()","first()","first()","floor()","following()","following_node_of()","fully_expanded_name()","function()","generate_event()","get_attribute()","get_attribute_ns()","get_elements()","get_first()","get_group()","get_listeners()","get_namespace()","get_namespace()","get_namespace()","get_procs()","get_text()","handle()","handle_entitydecl()","has_attributes?()","has_elements?()","has_name?()","has_name?()","has_next?()","has_text?()","hash()","id()","ignore_whitespace_nodes()","include?()","indent()","indent_text()","indent_text()","index()","index()","index_in_parent()","inject()","insert_after()","insert_before()","inspect()","inspect()","inspect()","inspect()","inspect()","inspect()","inspect()","inspect()","inspect()","inspect()","inspect()","instruction()","instruction?()","instructions()","lang()","last()","leave()","length()","length()","line()","listen()","literalize()","local_name()","local_name()","local_name=()","match()","match()","match()","match()","match()","match_to()","match_to_consume()","matches?()","matches?()","matches?()","matches?()","matches?()","matches?()","matches?()","method_missing()","name()","name()","name()","name()","name()","name=()","name=()","namespace()","namespace()","namespace()","namespace=()","namespace_context()","namespace_context=()","namespace_of()","namespace_uri()","namespaces()","namespaces()","namespaces=()","namespaces=()","namesplit()","need_source_encoding_update?()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","next()","next()","next()","next()","next()","next()","next_current()","next_element()","next_sibling=()","next_sibling_node()","next_sibling_node()","node_test()","node_type()","node_type()","node_type()","node_type()","node_type()","node_type()","node_type()","node_type()","node_type()","node_type()","norm()","normalize()","normalize()","normalize_compare_values()","normalize_space()","normalized()","not()","notation()","notationdecl()","notationdecl()","notationdecl?()","notations()","nowrite()","number()","old_enc=()","parent()","parent=()","parent=()","parent=()","parent?()","parent?()","parse()","parse()","parse()","parse()","parse()","parse()","parse()","parse()","parse_args()","parse_args()","parse_attributes()","parse_helper()","parse_source()","parse_source()","parse_stream()","peek()","peek()","position()","position()","position()","position()","position()","position()","preceding()","preceding_node_of()","predicate()","predicate()","predicate()","predicate_to_string()","prefix()","prefix()","prefix_of()","prefixes()","prefixes()","previous=()","previous_element()","previous_sibling=()","previous_sibling_node()","process_instruction()","processing_instruction()","processing_instruction()","progress()","public()","pull()","pull()","pull_event()","push()","raw()","read()","read()","read_with_substitution()","readline()","receive()","record_entity_expansion()","remove()","remove()","replace_child()","replace_with()","reset()","reset()","reset()","reset()","reset()","rewind()","rewind()","root()","root()","root()","root_node()","round()","scan()","scan()","send()","single?()","singleton_method_added()","size()","size()","size()","size()","sort()","source()","stand_alone?()","start_document()","start_element()","start_element?()","start_prefix_mapping()","starts_with()","step()","stream=()","strict?()","string()","string_length()","string_value()","strip_quotes()","substring()","substring_after()","substring_before()","sum()","system()","tag_end()","tag_start()","text()","text()","text()","text=()","text=()","text?()","texts()","to_a()","to_a()","to_a()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_string()","trace()","translate()","true()","unnode()","unnormalize()","unnormalize()","unnormalized()","unshift()","unshift()","unshift()","validate()","value()","value()","value()","value()","value=()","value_type()","variables()","variables=()","variables=()","version()","whitespace()","wrap()","wrap()","write()","write()","write()","write()","write()","write()","write()","write()","write()","write()","write()","write()","write()","write()","write()","write()","write()","write_cdata()","write_cdata()","write_comment()","write_comment()","write_document()","write_document()","write_element()","write_element()","write_element()","write_instruction()","write_text()","write_text()","write_text()","write_with_substitution()","xml_decl()","xmldecl()","xmldecl()","xmldecl()","xmldecl?()","xpath()","xpath()","xpath()"],"longSearchIndex":["array","float","integer","object","rexml","rexml::attlistdecl","rexml::attribute","rexml::attributes","rexml::cdata","rexml::child","rexml::comment","rexml::dtd","rexml::dtd::attlistdecl","rexml::dtd::elementdecl","rexml::dtd::entitydecl","rexml::dtd::notationdecl","rexml::dtd::parser","rexml::declaration","rexml::doctype","rexml::document","rexml::element","rexml::elementdecl","rexml::elements","rexml::encoding","rexml::entity","rexml::entityconst","rexml::externalentity","rexml::formatters","rexml::formatters::default","rexml::formatters::pretty","rexml::formatters::transitive","rexml::functions","rexml::iosource","rexml::instruction","rexml::light","rexml::light::node","rexml::namespace","rexml::node","rexml::notationdecl","rexml::output","rexml::parent","rexml::parseexception","rexml::parsers","rexml::parsers::baseparser","rexml::parsers::lightparser","rexml::parsers::pullevent","rexml::parsers::pullparser","rexml::parsers::sax2parser","rexml::parsers::streamparser","rexml::parsers::treeparser","rexml::parsers::ultralightparser","rexml::parsers::xpathparser","rexml::quickpath","rexml::sax2listener","rexml::security","rexml::source","rexml::sourcefactory","rexml::streamlistener","rexml::text","rexml::undefinednamespaceexception","rexml::validation","rexml::validation::choice","rexml::validation::event","rexml::validation::interleave","rexml::validation::oneormore","rexml::validation::optional","rexml::validation::ref","rexml::validation::relaxng","rexml::validation::sequence","rexml::validation::state","rexml::validation::validationexception","rexml::validation::validator","rexml::validation::zeroormore","rexml::xmldecl","rexml::xmltokens","rexml::xpath","rexml::xpathnode","rexml::xpathparser","symbol","rexml::attributes#<<()","rexml::document#<<()","rexml::elements#<<()","rexml::light::node#<<()","rexml::output#<<()","rexml::parent#<<()","rexml::text#<<()","rexml::validation::choice#<<()","rexml::validation::state#<<()","rexml::comment#<=>()","rexml::text#<=>()","rexml::attribute#==()","rexml::comment#==()","rexml::instruction#==()","rexml::validation::event#==()","rexml::xmldecl#==()","rexml::light::node#=~()","rexml::parsers::xpathparser#additiveexpr()","rexml::parsers::xpathparser#andexpr()","rexml::parsers::xpathparser#equalityexpr()","rexml::parsers::xpathparser#filterexpr()","rexml::parsers::xpathparser#functioncall()","rexml::parsers::xpathparser#locationpath()","rexml::parsers::xpathparser#multiplicativeexpr()","rexml::parsers::xpathparser#nodetest()","rexml::parsers::xpathparser#orexpr()","rexml::parsers::xpathparser#pathexpr()","rexml::parsers::xpathparser#predicate()","rexml::parsers::xpathparser#primaryexpr()","rexml::parsers::xpathparser#relationalexpr()","rexml::parsers::xpathparser#relativelocationpath()","rexml::parsers::xpathparser#unaryexpr()","rexml::parsers::xpathparser#unionexpr()","rexml::attlistdecl#[]()","rexml::attributes#[]()","rexml::element#[]()","rexml::elements#[]()","rexml::light::node#[]()","rexml::parent#[]()","rexml::parsers::pullevent#[]()","rexml::attributes#[]=()","rexml::elements#[]=()","rexml::light::node#[]=()","rexml::parent#[]=()","rexml::xpathparser#[]=()","rexml::element#__to_xpath_helper()","rexml::parsers::xpathparser#abbreviate()","rexml::attributes#add()","rexml::doctype#add()","rexml::document#add()","rexml::elements#add()","rexml::parent#add()","rexml::parsers::sax2parser#add()","rexml::element#add_attribute()","rexml::element#add_attributes()","rexml::document#add_element()","rexml::element#add_element()","rexml::validation::choice#add_event_to_arry()","rexml::validation::state#add_event_to_arry()","rexml::parsers::baseparser#add_listener()","rexml::parsers::lightparser#add_listener()","rexml::parsers::pullparser#add_listener()","rexml::parsers::sax2parser#add_listener()","rexml::parsers::streamparser#add_listener()","rexml::parsers::treeparser#add_listener()","rexml::parsers::ultralightparser#add_listener()","rexml::element#add_namespace()","rexml::element#add_text()","rexml::sax2listener#attlistdecl()","rexml::streamlistener#attlistdecl()","rexml::parsers::pullevent#attlistdecl?()","rexml::element#attribute()","rexml::quickpath::attribute()","rexml::doctype#attribute_of()","rexml::doctype#attributes_of()","rexml::quickpath::axe()","rexml::functions::boolean()","rexml::document#build()","rexml::child#bytes()","rexml::sax2listener#cdata()","rexml::streamlistener#cdata()","rexml::parsers::pullevent#cdata?()","rexml::element#cdatas()","rexml::functions::ceiling()","rexml::sax2listener#characters()","rexml::text::check()","rexml::xpathparser#child()","rexml::light::node#children()","rexml::parent#children()","rexml::text#clear_cache()","rexml::attribute#clone()","rexml::cdata#clone()","rexml::comment#clone()","rexml::doctype#clone()","rexml::document#clone()","rexml::element#clone()","rexml::instruction#clone()","rexml::text#clone()","rexml::xmldecl#clone()","rexml::elements#collect()","rexml::sax2listener#comment()","rexml::streamlistener#comment()","rexml::parsers::pullevent#comment?()","rexml::element#comments()","rexml::xpathparser#compare()","rexml::functions::compare_language()","rexml::functions::concat()","rexml::iosource#consume()","rexml::source#consume()","rexml::functions::contains()","rexml::xmldecl#content()","rexml::doctype#context()","rexml::parseexception#context()","rexml::functions::context=()","rexml::functions::count()","rexml::sourcefactory::create_from()","rexml::iosource#current_line()","rexml::source#current_line()","array#dclone()","float#dclone()","integer#dclone()","object#dclone()","symbol#dclone()","rexml::parsers::sax2parser#deafen()","rexml::encoding#decode()","rexml::parent#deep_clone()","rexml::xmldecl::default()","rexml::attributes#delete()","rexml::elements#delete()","rexml::parent#delete()","rexml::attributes#delete_all()","rexml::elements#delete_all()","rexml::parent#delete_at()","rexml::element#delete_attribute()","rexml::element#delete_element()","rexml::parent#delete_if()","rexml::element#delete_namespace()","rexml::xpathparser#descendant()","rexml::xpathparser#descendant_recursive()","rexml::source#detect_encoding()","rexml::attribute#doctype()","rexml::document#doctype()","rexml::sax2listener#doctype()","rexml::streamlistener#doctype()","rexml::text#doctype()","rexml::parsers::pullevent#doctype?()","rexml::streamlistener#doctype_end()","rexml::child#document()","rexml::document#document()","rexml::element#document()","rexml::validation::event#done?()","rexml::xmldecl#dowrite()","rexml::validation::validator#dump()","rexml::attlistdecl#each()","rexml::attributes#each()","rexml::elements#each()","rexml::light::node#each()","rexml::parent#each()","rexml::parsers::pullparser#each()","rexml::quickpath::each()","rexml::xpath::each()","rexml::attributes#each_attribute()","rexml::parent#each_child()","rexml::element#each_element()","rexml::element#each_element_with_attribute()","rexml::element#each_element_with_text()","rexml::parent#each_index()","rexml::node#each_recursive()","rexml::xpathparser#each_unnode()","rexml::element#each_with_something()","rexml::attribute#element=()","rexml::sax2listener#elementdecl()","rexml::streamlistener#elementdecl()","rexml::parsers::pullevent#elementdecl?()","rexml::elements#empty?()","rexml::iosource#empty?()","rexml::parsers::baseparser#empty?()","rexml::source#empty?()","rexml::text#empty?()","rexml::encoding#encode()","rexml::document#encoding()","rexml::encoding#encoding=()","rexml::source#encoding=()","rexml::xmldecl#encoding=()","rexml::iosource#encoding_updated()","rexml::source#encoding_updated()","rexml::sax2listener#end_document()","rexml::sax2listener#end_element()","rexml::parsers::pullevent#end_element?()","rexml::sax2listener#end_prefix_mapping()","rexml::xpathparser#enter()","rexml::doctype#entity()","rexml::parsers::baseparser#entity()","rexml::streamlistener#entity()","rexml::parsers::pullevent#entity?()","rexml::document::entity_expansion_limit()","rexml::security::entity_expansion_limit()","rexml::document::entity_expansion_limit=()","rexml::security::entity_expansion_limit=()","rexml::document::entity_expansion_text_limit()","rexml::security::entity_expansion_text_limit()","rexml::document::entity_expansion_text_limit=()","rexml::security::entity_expansion_text_limit=()","rexml::sax2listener#entitydecl()","rexml::streamlistener#entitydecl()","rexml::parsers::pullevent#entitydecl?()","rexml::xpathparser#equality_relational_compare()","rexml::parsers::pullevent#error?()","rexml::xpathparser#evaluate_predicate()","rexml::parsers::pullevent#event_type()","rexml::parsers::xpathparser#expand()","rexml::text::expand()","rexml::validation::state#expand_ref_in()","rexml::document#expanded_name()","rexml::validation::choice#expected()","rexml::validation::interleave#expected()","rexml::validation::oneormore#expected()","rexml::validation::optional#expected()","rexml::validation::state#expected()","rexml::validation::zeroormore#expected()","rexml::xpathparser#expr()","rexml::functions::false()","rexml::quickpath::filter()","rexml::xpathparser#filter_nodeset()","rexml::encoding#find_encoding()","rexml::node#find_first_recursive()","rexml::quickpath::first()","rexml::xpath::first()","rexml::xpathparser#first()","rexml::functions::floor()","rexml::xpathparser#following()","rexml::xpathparser#following_node_of()","rexml::namespace#fully_expanded_name()","rexml::quickpath::function()","rexml::validation::state#generate_event()","rexml::attributes#get_attribute()","rexml::attributes#get_attribute_ns()","rexml::element#get_elements()","rexml::xpathparser#get_first()","rexml::parsers::xpathparser#get_group()","rexml::parsers::sax2parser#get_listeners()","rexml::functions::get_namespace()","rexml::parsers::sax2parser#get_namespace()","rexml::xpathparser#get_namespace()","rexml::parsers::sax2parser#get_procs()","rexml::element#get_text()","rexml::parsers::sax2parser#handle()","rexml::parsers::sax2parser#handle_entitydecl()","rexml::element#has_attributes?()","rexml::element#has_elements?()","rexml::light::node#has_name?()","rexml::namespace#has_name?()","rexml::parsers::baseparser#has_next?()","rexml::element#has_text?()","rexml::attribute#hash()","rexml::functions::id()","rexml::element#ignore_whitespace_nodes()","rexml::attlistdecl#include?()","rexml::node#indent()","rexml::formatters::pretty#indent_text()","rexml::text#indent_text()","rexml::elements#index()","rexml::parent#index()","rexml::node#index_in_parent()","rexml::elements#inject()","rexml::parent#insert_after()","rexml::parent#insert_before()","rexml::attribute#inspect()","rexml::element#inspect()","rexml::instruction#inspect()","rexml::parsers::pullevent#inspect()","rexml::text#inspect()","rexml::validation::choice#inspect()","rexml::validation::event#inspect()","rexml::validation::interleave#inspect()","rexml::validation::ref#inspect()","rexml::validation::state#inspect()","rexml::xmldecl#inspect()","rexml::streamlistener#instruction()","rexml::parsers::pullevent#instruction?()","rexml::element#instructions()","rexml::functions::lang()","rexml::functions::last()","rexml::xpathparser#leave()","rexml::attributes#length()","rexml::parent#length()","rexml::parseexception#line()","rexml::parsers::sax2parser#listen()","rexml::elements#literalize()","rexml::functions::local_name()","rexml::light::node#local_name()","rexml::light::node#local_name=()","rexml::iosource#match()","rexml::quickpath::match()","rexml::source#match()","rexml::xpath::match()","rexml::xpathparser#match()","rexml::source#match_to()","rexml::source#match_to_consume()","rexml::entity::matches?()","rexml::validation::choice#matches?()","rexml::validation::event#matches?()","rexml::validation::interleave#matches?()","rexml::validation::oneormore#matches?()","rexml::validation::optional#matches?()","rexml::validation::sequence#matches?()","rexml::quickpath::method_missing()","rexml::document#name()","rexml::functions::name()","rexml::light::node#name()","rexml::notationdecl#name()","rexml::quickpath::name()","rexml::light::node#name=()","rexml::namespace#name=()","rexml::attribute#namespace()","rexml::element#namespace()","rexml::light::node#namespace()","rexml::light::node#namespace=()","rexml::functions::namespace_context()","rexml::functions::namespace_context=()","rexml::light::node#namespace_of()","rexml::functions::namespace_uri()","rexml::attributes#namespaces()","rexml::element#namespaces()","rexml::parsers::xpathparser#namespaces=()","rexml::xpathparser#namespaces=()","rexml::light::node#namesplit()","rexml::parsers::baseparser#need_source_encoding_update?()","rexml::attlistdecl::new()","rexml::attribute::new()","rexml::attributes::new()","rexml::cdata::new()","rexml::child::new()","rexml::comment::new()","rexml::dtd::elementdecl::new()","rexml::dtd::entitydecl::new()","rexml::dtd::notationdecl::new()","rexml::declaration::new()","rexml::doctype::new()","rexml::document::new()","rexml::element::new()","rexml::elementdecl::new()","rexml::elements::new()","rexml::entity::new()","rexml::externalentity::new()","rexml::formatters::default::new()","rexml::formatters::pretty::new()","rexml::formatters::transitive::new()","rexml::iosource::new()","rexml::instruction::new()","rexml::light::node::new()","rexml::notationdecl::new()","rexml::output::new()","rexml::parent::new()","rexml::parseexception::new()","rexml::parsers::baseparser::new()","rexml::parsers::lightparser::new()","rexml::parsers::pullevent::new()","rexml::parsers::pullparser::new()","rexml::parsers::sax2parser::new()","rexml::parsers::streamparser::new()","rexml::parsers::treeparser::new()","rexml::parsers::ultralightparser::new()","rexml::source::new()","rexml::text::new()","rexml::undefinednamespaceexception::new()","rexml::validation::choice::new()","rexml::validation::event::new()","rexml::validation::interleave::new()","rexml::validation::oneormore::new()","rexml::validation::ref::new()","rexml::validation::relaxng::new()","rexml::validation::state::new()","rexml::validation::validationexception::new()","rexml::xmldecl::new()","rexml::xpathnode::new()","rexml::xpathparser::new()","rexml::validation::choice#next()","rexml::validation::interleave#next()","rexml::validation::oneormore#next()","rexml::validation::optional#next()","rexml::validation::state#next()","rexml::validation::zeroormore#next()","rexml::validation::interleave#next_current()","rexml::element#next_element()","rexml::child#next_sibling=()","rexml::node#next_sibling_node()","rexml::xpathparser#next_sibling_node()","rexml::xpathparser#node_test()","rexml::attlistdecl#node_type()","rexml::attribute#node_type()","rexml::comment#node_type()","rexml::doctype#node_type()","rexml::document#node_type()","rexml::element#node_type()","rexml::instruction#node_type()","rexml::light::node#node_type()","rexml::text#node_type()","rexml::xmldecl#node_type()","rexml::xpathparser#norm()","rexml::parsers::baseparser#normalize()","rexml::text::normalize()","rexml::xpathparser#normalize_compare_values()","rexml::functions::normalize_space()","rexml::entity#normalized()","rexml::functions::not()","rexml::doctype#notation()","rexml::sax2listener#notationdecl()","rexml::streamlistener#notationdecl()","rexml::parsers::pullevent#notationdecl?()","rexml::doctype#notations()","rexml::xmldecl#nowrite()","rexml::functions::number()","rexml::xmldecl#old_enc=()","rexml::light::node#parent()","rexml::child#parent=()","rexml::light::node#parent=()","rexml::text#parent=()","rexml::node#parent?()","rexml::parent#parent?()","rexml::dtd::parser::parse()","rexml::parsers::lightparser#parse()","rexml::parsers::sax2parser#parse()","rexml::parsers::streamparser#parse()","rexml::parsers::treeparser#parse()","rexml::parsers::ultralightparser#parse()","rexml::parsers::xpathparser#parse()","rexml::xpathparser#parse()","rexml::parsers::xpathparser#parse_args()","rexml::quickpath::parse_args()","rexml::parsers::baseparser#parse_attributes()","rexml::dtd::parser::parse_helper()","rexml::dtd::entitydecl::parse_source()","rexml::dtd::notationdecl::parse_source()","rexml::document::parse_stream()","rexml::parsers::baseparser#peek()","rexml::parsers::pullparser#peek()","rexml::functions::position()","rexml::iosource#position()","rexml::parseexception#position()","rexml::parsers::baseparser#position()","rexml::source#position()","rexml::xpathnode#position()","rexml::xpathparser#preceding()","rexml::xpathparser#preceding_node_of()","rexml::parsers::xpathparser#predicate()","rexml::quickpath::predicate()","rexml::xpathparser#predicate()","rexml::parsers::xpathparser#predicate_to_string()","rexml::attribute#prefix()","rexml::light::node#prefix()","rexml::light::node#prefix_of()","rexml::attributes#prefixes()","rexml::element#prefixes()","rexml::validation::state#previous=()","rexml::element#previous_element()","rexml::child#previous_sibling=()","rexml::node#previous_sibling_node()","rexml::parsers::baseparser#process_instruction()","rexml::functions::processing_instruction()","rexml::sax2listener#processing_instruction()","rexml::sax2listener#progress()","rexml::doctype#public()","rexml::parsers::baseparser#pull()","rexml::parsers::pullparser#pull()","rexml::parsers::baseparser#pull_event()","rexml::parent#push()","rexml::element#raw()","rexml::iosource#read()","rexml::source#read()","rexml::text::read_with_substitution()","rexml::iosource#readline()","rexml::validation::relaxng#receive()","rexml::document#record_entity_expansion()","rexml::attribute#remove()","rexml::child#remove()","rexml::parent#replace_child()","rexml::child#replace_with()","rexml::validation::choice#reset()","rexml::validation::interleave#reset()","rexml::validation::oneormore#reset()","rexml::validation::state#reset()","rexml::validation::validator#reset()","rexml::parsers::lightparser#rewind()","rexml::parsers::ultralightparser#rewind()","rexml::document#root()","rexml::element#root()","rexml::light::node#root()","rexml::element#root_node()","rexml::functions::round()","rexml::iosource#scan()","rexml::source#scan()","rexml::functions::send()","rexml::validation::event#single?()","rexml::functions::singleton_method_added()","rexml::attributes#size()","rexml::elements#size()","rexml::light::node#size()","rexml::parent#size()","rexml::xpathparser#sort()","rexml::parsers::sax2parser#source()","rexml::document#stand_alone?()","rexml::sax2listener#start_document()","rexml::sax2listener#start_element()","rexml::parsers::pullevent#start_element?()","rexml::sax2listener#start_prefix_mapping()","rexml::functions::starts_with()","rexml::xpathparser#step()","rexml::parsers::baseparser#stream=()","rexml::xpathparser#strict?()","rexml::functions::string()","rexml::functions::string_length()","rexml::functions::string_value()","rexml::doctype#strip_quotes()","rexml::functions::substring()","rexml::functions::substring_after()","rexml::functions::substring_before()","rexml::functions::sum()","rexml::doctype#system()","rexml::streamlistener#tag_end()","rexml::streamlistener#tag_start()","rexml::element#text()","rexml::functions::text()","rexml::streamlistener#text()","rexml::element#text=()","rexml::light::node#text=()","rexml::parsers::pullevent#text?()","rexml::element#texts()","rexml::attributes#to_a()","rexml::elements#to_a()","rexml::parent#to_a()","rexml::attribute#to_s()","rexml::cdata#to_s()","rexml::dtd::entitydecl#to_s()","rexml::dtd::notationdecl#to_s()","rexml::declaration#to_s()","rexml::entity#to_s()","rexml::externalentity#to_s()","rexml::light::node#to_s()","rexml::node#to_s()","rexml::notationdecl#to_s()","rexml::output#to_s()","rexml::parseexception#to_s()","rexml::text#to_s()","rexml::validation::event#to_s()","rexml::validation::ref#to_s()","rexml::validation::state#to_s()","rexml::attribute#to_string()","rexml::xpathparser#trace()","rexml::functions::translate()","rexml::functions::true()","rexml::xpathparser#unnode()","rexml::parsers::baseparser#unnormalize()","rexml::text::unnormalize()","rexml::entity#unnormalized()","rexml::parent#unshift()","rexml::parsers::baseparser#unshift()","rexml::parsers::pullparser#unshift()","rexml::validation::validator#validate()","rexml::attribute#value()","rexml::cdata#value()","rexml::entity#value()","rexml::text#value()","rexml::text#value=()","rexml::xpathparser#value_type()","rexml::functions::variables()","rexml::functions::variables=()","rexml::xpathparser#variables=()","rexml::document#version()","rexml::element#whitespace()","rexml::formatters::pretty#wrap()","rexml::text#wrap()","rexml::attlistdecl#write()","rexml::attribute#write()","rexml::cdata#write()","rexml::comment#write()","rexml::dtd::entitydecl#write()","rexml::dtd::notationdecl#write()","rexml::declaration#write()","rexml::doctype#write()","rexml::document#write()","rexml::element#write()","rexml::entity#write()","rexml::externalentity#write()","rexml::formatters::default#write()","rexml::instruction#write()","rexml::notationdecl#write()","rexml::text#write()","rexml::xmldecl#write()","rexml::formatters::default#write_cdata()","rexml::formatters::pretty#write_cdata()","rexml::formatters::default#write_comment()","rexml::formatters::pretty#write_comment()","rexml::formatters::default#write_document()","rexml::formatters::pretty#write_document()","rexml::formatters::default#write_element()","rexml::formatters::pretty#write_element()","rexml::formatters::transitive#write_element()","rexml::formatters::default#write_instruction()","rexml::formatters::default#write_text()","rexml::formatters::pretty#write_text()","rexml::formatters::transitive#write_text()","rexml::text#write_with_substitution()","rexml::document#xml_decl()","rexml::sax2listener#xmldecl()","rexml::streamlistener#xmldecl()","rexml::xmldecl#xmldecl()","rexml::parsers::pullevent#xmldecl?()","rexml::attribute#xpath()","rexml::element#xpath()","rexml::text#xpath()"],"info":[["Array","","Array.html","",""],["Float","","Float.html","",""],["Integer","","Integer.html","",""],["Object","","Object.html","",""],["REXML","","REXML.html","","<p> :element, parent, name, attributes, children*  &mdash; a = Node.new a &lt;&lt; “B”            # =&gt; …\n\n"],["REXML::AttlistDecl","","REXML/AttlistDecl.html","","<p>This class needs:\n<p>Documentation\n<p>Work!  Not all types of attlists are intelligently parsed, so we just\n"],["REXML::Attribute","","REXML/Attribute.html","","<p>Defines an Element Attribute; IE, a attribute=value pair, as in: &lt;element attribute=“value”/&gt;. …\n"],["REXML::Attributes","","REXML/Attributes.html","","<p>A class that defines the set of Attributes of an Element and provides operations for accessing elements …\n"],["REXML::CData","","REXML/CData.html","",""],["REXML::Child","","REXML/Child.html","","<p>A Child object is something contained by a parent, and this class contains methods to support that.  …\n"],["REXML::Comment","","REXML/Comment.html","","<p>Represents an XML comment; that is, text between &lt;!– … –&gt;\n"],["REXML::DTD","","REXML/DTD.html","",""],["REXML::DTD::AttlistDecl","","REXML/DTD/AttlistDecl.html","",""],["REXML::DTD::ElementDecl","","REXML/DTD/ElementDecl.html","",""],["REXML::DTD::EntityDecl","","REXML/DTD/EntityDecl.html","",""],["REXML::DTD::NotationDecl","","REXML/DTD/NotationDecl.html","",""],["REXML::DTD::Parser","","REXML/DTD/Parser.html","",""],["REXML::Declaration","","REXML/Declaration.html","","<p>This is an abstract class.  You never use this directly; it serves as a parent class for the specific …\n"],["REXML::DocType","","REXML/DocType.html","","<p>Represents an XML DOCTYPE declaration; that is, the contents of &lt;!DOCTYPE … &gt;.  DOCTYPES can …\n"],["REXML::Document","","REXML/Document.html","","<p>Represents a full XML document, including PIs, a doctype, etc.  A Document has a single child that can …\n"],["REXML::Element","","REXML/Element.html","","<p>Represents a tagged XML element.  Elements are characterized by having children, attributes, and names, …\n"],["REXML::ElementDecl","","REXML/ElementDecl.html","",""],["REXML::Elements","","REXML/Elements.html","","<p>A class which provides filtering of children for Elements, and XPath search support.  You are expected …\n"],["REXML::Encoding","","REXML/Encoding.html","",""],["REXML::Entity","","REXML/Entity.html","",""],["REXML::EntityConst","","REXML/EntityConst.html","","<p>This is a set of entity constants – the ones defined in the XML specification.  These are <code>gt</code>, <code>lt</code>, <code>amp</code> …\n"],["REXML::ExternalEntity","","REXML/ExternalEntity.html","",""],["REXML::Formatters","","REXML/Formatters.html","",""],["REXML::Formatters::Default","","REXML/Formatters/Default.html","",""],["REXML::Formatters::Pretty","","REXML/Formatters/Pretty.html","","<p>Pretty-prints an XML document.  This destroys whitespace in text nodes and will insert carriage returns …\n"],["REXML::Formatters::Transitive","","REXML/Formatters/Transitive.html","","<p>The Transitive formatter writes an XML document that parses to an identical document as the source document. …\n"],["REXML::Functions","","REXML/Functions.html","","<p>If you add a method, keep in mind two things: (1) the first argument will always be a list of nodes from …\n"],["REXML::IOSource","","REXML/IOSource.html","","<p>A Source that wraps an IO.  See the Source class for method documentation\n"],["REXML::Instruction","","REXML/Instruction.html","","<p>Represents an XML Instruction; IE, &lt;? … ?&gt; TODO: Add parent arg (3rd arg) to constructor\n"],["REXML::Light","","REXML/Light.html","",""],["REXML::Light::Node","","REXML/Light/Node.html","","<p>Represents a tagged XML element.  Elements are characterized by having children, attributes, and names, …\n"],["REXML::Namespace","","REXML/Namespace.html","","<p>Adds named attributes to an object.\n"],["REXML::Node","","REXML/Node.html","","<p>Represents a node in the tree.  Nodes are never encountered except as superclasses of other objects. …\n"],["REXML::NotationDecl","","REXML/NotationDecl.html","",""],["REXML::Output","","REXML/Output.html","",""],["REXML::Parent","","REXML/Parent.html","","<p>A parent has children, and has methods for accessing them.  The Parent class is never encountered except …\n"],["REXML::ParseException","","REXML/ParseException.html","",""],["REXML::Parsers","","REXML/Parsers.html","",""],["REXML::Parsers::BaseParser","","REXML/Parsers/BaseParser.html","","<p>Using the Pull Parser\n<p><em>This API is experimental, and subject to change.</em>\n\n<pre>parser = PullParser.new( &quot;&lt;a&gt;text&lt;b ...</pre>\n"],["REXML::Parsers::LightParser","","REXML/Parsers/LightParser.html","",""],["REXML::Parsers::PullEvent","","REXML/Parsers/PullEvent.html","","<p>A parsing event.  The contents of the event are accessed as an +Array?, and the type is given either …\n"],["REXML::Parsers::PullParser","","REXML/Parsers/PullParser.html","","<p>Using the Pull Parser\n<p><em>This API is experimental, and subject to change.</em>\n\n<pre>parser = PullParser.new( &quot;&lt;a&gt;text&lt;b ...</pre>\n"],["REXML::Parsers::SAX2Parser","","REXML/Parsers/SAX2Parser.html","","<p>SAX2Parser\n"],["REXML::Parsers::StreamParser","","REXML/Parsers/StreamParser.html","",""],["REXML::Parsers::TreeParser","","REXML/Parsers/TreeParser.html","",""],["REXML::Parsers::UltraLightParser","","REXML/Parsers/UltraLightParser.html","",""],["REXML::Parsers::XPathParser","","REXML/Parsers/XPathParser.html","","<p>You don&#39;t want to use this class.  Really.  Use XPath, which is a wrapper for this class.  Believe …\n"],["REXML::QuickPath","","REXML/QuickPath.html","",""],["REXML::SAX2Listener","","REXML/SAX2Listener.html","","<p>A template for stream parser listeners. Note that the declarations (attlistdecl, elementdecl, etc) are …\n"],["REXML::Security","","REXML/Security.html","",""],["REXML::Source","","REXML/Source.html","","<p>A Source can be searched for patterns, and wraps buffers and other objects and provides consumption of …\n"],["REXML::SourceFactory","","REXML/SourceFactory.html","","<p>Generates Source-s.  USE THIS CLASS.\n"],["REXML::StreamListener","","REXML/StreamListener.html","","<p>A template for stream parser listeners. Note that the declarations (attlistdecl, elementdecl, etc) are …\n"],["REXML::Text","","REXML/Text.html","","<p>Represents text nodes in an XML document\n"],["REXML::UndefinedNamespaceException","","REXML/UndefinedNamespaceException.html","",""],["REXML::Validation","","REXML/Validation.html","",""],["REXML::Validation::Choice","","REXML/Validation/Choice.html","",""],["REXML::Validation::Event","","REXML/Validation/Event.html","",""],["REXML::Validation::Interleave","","REXML/Validation/Interleave.html","",""],["REXML::Validation::OneOrMore","","REXML/Validation/OneOrMore.html","",""],["REXML::Validation::Optional","","REXML/Validation/Optional.html","",""],["REXML::Validation::Ref","","REXML/Validation/Ref.html","",""],["REXML::Validation::RelaxNG","","REXML/Validation/RelaxNG.html","","<p>Implemented:\n<p>empty\n<p>element\n"],["REXML::Validation::Sequence","","REXML/Validation/Sequence.html","",""],["REXML::Validation::State","","REXML/Validation/State.html","",""],["REXML::Validation::ValidationException","","REXML/Validation/ValidationException.html","",""],["REXML::Validation::Validator","","REXML/Validation/Validator.html","",""],["REXML::Validation::ZeroOrMore","","REXML/Validation/ZeroOrMore.html","",""],["REXML::XMLDecl","","REXML/XMLDecl.html","","<p>NEEDS DOCUMENTATION\n"],["REXML::XMLTokens","","REXML/XMLTokens.html","","<p>Defines a number of tokens used for parsing XML.  Not for general consumption.\n"],["REXML::XPath","","REXML/XPath.html","","<p>Wrapper class.  Use this class to access the XPath functions.\n"],["REXML::XPathNode","","REXML/XPathNode.html","","<p>@private\n"],["REXML::XPathParser","","REXML/XPathParser.html","","<p>You don&#39;t want to use this class.  Really.  Use XPath, which is a wrapper for this class.  Believe …\n"],["Symbol","","Symbol.html","",""],["<<","REXML::Attributes","REXML/Attributes.html#method-i-3C-3C","( attribute )",""],["<<","REXML::Document","REXML/Document.html#method-i-3C-3C","( child )",""],["<<","REXML::Elements","REXML/Elements.html#method-i-3C-3C","(element=nil)",""],["<<","REXML::Light::Node","REXML/Light/Node.html#method-i-3C-3C","(element)","<p>Append a child to this element, optionally under a provided namespace. The namespace argument is ignored …\n"],["<<","REXML::Output","REXML/Output.html#method-i-3C-3C","( content )",""],["<<","REXML::Parent","REXML/Parent.html#method-i-3C-3C","( object )",""],["<<","REXML::Text","REXML/Text.html#method-i-3C-3C","( to_append )","<p>Appends text to this text node.  The text is appended in the <code>raw</code> mode of this text node.\n<p><code>returns</code> the text …\n"],["<<","REXML::Validation::Choice","REXML/Validation/Choice.html#method-i-3C-3C","( event )",""],["<<","REXML::Validation::State","REXML/Validation/State.html#method-i-3C-3C","( event )",""],["<=>","REXML::Comment","REXML/Comment.html#method-i-3C-3D-3E","(other)","<p>Compares this Comment to another; the contents of the comment are used in the comparison.\n"],["<=>","REXML::Text","REXML/Text.html#method-i-3C-3D-3E","( other )","<p><code>other</code> a String or a Text <code>returns</code> the result of (to_s &lt;=&gt; arg.to_s)\n"],["==","REXML::Attribute","REXML/Attribute.html#method-i-3D-3D","( other )","<p>Returns true if other is an Attribute and has the same name and value, false otherwise.\n"],["==","REXML::Comment","REXML/Comment.html#method-i-3D-3D","( other )","<p>Compares this Comment to another; the contents of the comment are used in the comparison.\n"],["==","REXML::Instruction","REXML/Instruction.html#method-i-3D-3D","( other )","<p>@return true if other is an Instruction, and the content and target of the other matches the target and …\n"],["==","REXML::Validation::Event","REXML/Validation/Event.html#method-i-3D-3D","( other )",""],["==","REXML::XMLDecl","REXML/XMLDecl.html#method-i-3D-3D","( other )",""],["=~","REXML::Light::Node","REXML/Light/Node.html#method-i-3D~","( path )",""],["AdditiveExpr","REXML::Parsers::XPathParser","REXML/Parsers/XPathParser.html#method-i-AdditiveExpr","(path, parsed)","<p>| AdditiveExpr (&#39;+&#39; | &#39;-&#39;) MultiplicativeExpr | MultiplicativeExpr\n"],["AndExpr","REXML::Parsers::XPathParser","REXML/Parsers/XPathParser.html#method-i-AndExpr","(path, parsed)","<p>| AndExpr S &#39;and&#39; S EqualityExpr | EqualityExpr\n"],["EqualityExpr","REXML::Parsers::XPathParser","REXML/Parsers/XPathParser.html#method-i-EqualityExpr","(path, parsed)","<p>| EqualityExpr (&#39;=&#39; | &#39;!=&#39;)  RelationalExpr | RelationalExpr\n"],["FilterExpr","REXML::Parsers::XPathParser","REXML/Parsers/XPathParser.html#method-i-FilterExpr","(path, parsed)","<p>| FilterExpr Predicate | PrimaryExpr\n"],["FunctionCall","REXML::Parsers::XPathParser","REXML/Parsers/XPathParser.html#method-i-FunctionCall","(rest, parsed)","<p>| FUNCTION_NAME &#39;(&#39; ( expr ( &#39;,&#39; expr )* )? &#39;)&#39;\n"],["LocationPath","REXML::Parsers::XPathParser","REXML/Parsers/XPathParser.html#method-i-LocationPath","(path, parsed)","<p>LocationPath\n\n<pre>| RelativeLocationPath\n| &#39;/&#39; RelativeLocationPath?\n| &#39;//&#39; RelativeLocationPath</pre>\n"],["MultiplicativeExpr","REXML::Parsers::XPathParser","REXML/Parsers/XPathParser.html#method-i-MultiplicativeExpr","(path, parsed)","<p>| MultiplicativeExpr (&#39;*&#39; | S (&#39;div&#39; | &#39;mod&#39;) S) UnaryExpr | UnaryExpr\n"],["NodeTest","REXML::Parsers::XPathParser","REXML/Parsers/XPathParser.html#method-i-NodeTest","(path, parsed)",""],["OrExpr","REXML::Parsers::XPathParser","REXML/Parsers/XPathParser.html#method-i-OrExpr","(path, parsed)","<p>| OrExpr S &#39;or&#39; S AndExpr | AndExpr\n"],["PathExpr","REXML::Parsers::XPathParser","REXML/Parsers/XPathParser.html#method-i-PathExpr","(path, parsed)","<p>| LocationPath | FilterExpr (&#39;/&#39; | &#39;//&#39;) RelativeLocationPath\n"],["Predicate","REXML::Parsers::XPathParser","REXML/Parsers/XPathParser.html#method-i-Predicate","(path, parsed)","<p>Filters the supplied nodeset on the predicate(s)\n"],["PrimaryExpr","REXML::Parsers::XPathParser","REXML/Parsers/XPathParser.html#method-i-PrimaryExpr","(path, parsed)",""],["RelationalExpr","REXML::Parsers::XPathParser","REXML/Parsers/XPathParser.html#method-i-RelationalExpr","(path, parsed)","<p>| RelationalExpr (&#39;&lt;&#39; | &#39;&gt;&#39; | &#39;&lt;=&#39; | &#39;&gt;=&#39;) AdditiveExpr | …\n"],["RelativeLocationPath","REXML::Parsers::XPathParser","REXML/Parsers/XPathParser.html#method-i-RelativeLocationPath","(path, parsed)",""],["UnaryExpr","REXML::Parsers::XPathParser","REXML/Parsers/XPathParser.html#method-i-UnaryExpr","(path, parsed)","<p>| &#39;-&#39; UnaryExpr | UnionExpr\n"],["UnionExpr","REXML::Parsers::XPathParser","REXML/Parsers/XPathParser.html#method-i-UnionExpr","(path, parsed)","<p>| UnionExpr &#39;|&#39; PathExpr | PathExpr\n"],["[]","REXML::AttlistDecl","REXML/AttlistDecl.html#method-i-5B-5D","(key)","<p>Access the attlist attribute/value pairs.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">value</span> = <span class=\"ruby-identifier\">attlist_decl</span>[ <span class=\"ruby-identifier\">attribute_name</span> ]\n</pre>\n"],["[]","REXML::Attributes","REXML/Attributes.html#method-i-5B-5D","(name)","<p>Fetches an attribute value.  If you want to get the Attribute itself, use get_attribute()\n<p>name &mdash; an XPath …\n"],["[]","REXML::Element","REXML/Element.html#method-i-5B-5D","(name_or_index)","<p>Fetches an attribute value or a child.\n<p>If String or Symbol is specified, it&#39;s treated as attribute …\n"],["[]","REXML::Elements","REXML/Elements.html#method-i-5B-5D","( index, name=nil)","<p>Fetches a child element.  Filters only Element children, regardless of the XPath match.\n<p>index &mdash; the search …\n"],["[]","REXML::Light::Node","REXML/Light/Node.html#method-i-5B-5D","( reference, ns=nil )",""],["[]","REXML::Parent","REXML/Parent.html#method-i-5B-5D","( index )","<p>Fetches a child at a given index @param index the Integer index of the child to fetch\n"],["[]","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-5B-5D","( start, endd=nil)",""],["[]=","REXML::Attributes","REXML/Attributes.html#method-i-5B-5D-3D","( name, value )","<p>Sets an attribute, overwriting any existing attribute value by the same name.  Namespace is significant. …\n"],["[]=","REXML::Elements","REXML/Elements.html#method-i-5B-5D-3D","( index, element )","<p>Sets an element, replacing any previous matching element.  If no existing element is found ,the element …\n"],["[]=","REXML::Light::Node","REXML/Light/Node.html#method-i-5B-5D-3D","( reference, ns, value=nil )","<p>Doesn&#39;t handle namespaces yet\n"],["[]=","REXML::Parent","REXML/Parent.html#method-i-5B-5D-3D","( *args )","<p>Set an index entry.  See Array.[]= @param index the index of the element to set @param opt either the …\n"],["[]=","REXML::XPathParser","REXML/XPathParser.html#method-i-5B-5D-3D","( variable_name, value )",""],["__to_xpath_helper","REXML::Element","REXML/Element.html#method-i-__to_xpath_helper","(node)",""],["abbreviate","REXML::Parsers::XPathParser","REXML/Parsers/XPathParser.html#method-i-abbreviate","( path )",""],["add","REXML::Attributes","REXML/Attributes.html#method-i-add","( attribute )","<p>Adds an attribute, overriding any existing attribute by the same name.  Namespaces are significant.\n<p>attribute … &mdash; "],["add","REXML::DocType","REXML/DocType.html#method-i-add","(child)",""],["add","REXML::Document","REXML/Document.html#method-i-add","( child )","<p>We override this, because XMLDecls and DocTypes must go at the start of the document\n"],["add","REXML::Elements","REXML/Elements.html#method-i-add","(element=nil)","<p>Adds an element\n<p>element &mdash; if supplied, is either an Element, String, or Source (see Element.initialize). …\n"],["add","REXML::Parent","REXML/Parent.html#method-i-add","( object )",""],["add","REXML::Parsers::SAX2Parser","REXML/Parsers/SAX2Parser.html#method-i-add","( pair )",""],["add_attribute","REXML::Element","REXML/Element.html#method-i-add_attribute","( key, value=nil )","<p>Adds an attribute to this element, overwriting any existing attribute by the same name.\n<p>key &mdash; can be either …\n"],["add_attributes","REXML::Element","REXML/Element.html#method-i-add_attributes","(hash)","<p>Add multiple attributes to this element.\n<p>hash &mdash; is either a hash, or array of arrays\n\n\n<pre>el.add_attributes( {&quot;name1&quot;=&gt;&quot;value1&quot;, ...</pre>\n"],["add_element","REXML::Document","REXML/Document.html#method-i-add_element","(arg=nil, arg2=nil)",""],["add_element","REXML::Element","REXML/Element.html#method-i-add_element","(element, attrs=nil)","<p>Adds a child to this element, optionally setting attributes in the element.\n<p>element &mdash; optional.  If Element …\n"],["add_event_to_arry","REXML::Validation::Choice","REXML/Validation/Choice.html#method-i-add_event_to_arry","( arry, evt )",""],["add_event_to_arry","REXML::Validation::State","REXML/Validation/State.html#method-i-add_event_to_arry","( arry, evt )",""],["add_listener","REXML::Parsers::BaseParser","REXML/Parsers/BaseParser.html#method-i-add_listener","( listener )",""],["add_listener","REXML::Parsers::LightParser","REXML/Parsers/LightParser.html#method-i-add_listener","( listener )",""],["add_listener","REXML::Parsers::PullParser","REXML/Parsers/PullParser.html#method-i-add_listener","( listener )",""],["add_listener","REXML::Parsers::SAX2Parser","REXML/Parsers/SAX2Parser.html#method-i-add_listener","( listener )",""],["add_listener","REXML::Parsers::StreamParser","REXML/Parsers/StreamParser.html#method-i-add_listener","( listener )",""],["add_listener","REXML::Parsers::TreeParser","REXML/Parsers/TreeParser.html#method-i-add_listener","( listener )",""],["add_listener","REXML::Parsers::UltraLightParser","REXML/Parsers/UltraLightParser.html#method-i-add_listener","( listener )",""],["add_namespace","REXML::Element","REXML/Element.html#method-i-add_namespace","( prefix, uri=nil )","<p>Adds a namespace to this element.\n<p>prefix &mdash; the prefix string, or the namespace URI if <code>uri</code> is not supplied …\n"],["add_text","REXML::Element","REXML/Element.html#method-i-add_text","( text )","<p>A helper method to add a Text child.  Actual Text instances can be added with regular Parent methods, …\n"],["attlistdecl","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-attlistdecl","(element, pairs, contents)","<p>If a doctype includes an ATTLIST declaration, it will cause this method to be called.  The content is …\n"],["attlistdecl","REXML::StreamListener","REXML/StreamListener.html#method-i-attlistdecl","(element_name, attributes, raw_content)","<p>If a doctype includes an ATTLIST declaration, it will cause this method to be called.  The content is …\n"],["attlistdecl?","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-attlistdecl-3F","()","<p>Content: [ String text ]\n"],["attribute","REXML::Element","REXML/Element.html#method-i-attribute","( name, namespace=nil )",""],["attribute","REXML::QuickPath","REXML/QuickPath.html#method-c-attribute","( name )",""],["attribute_of","REXML::DocType","REXML/DocType.html#method-i-attribute_of","(element, attribute)",""],["attributes_of","REXML::DocType","REXML/DocType.html#method-i-attributes_of","(element)",""],["axe","REXML::QuickPath","REXML/QuickPath.html#method-c-axe","( elements, axe_name, rest )",""],["boolean","REXML::Functions","REXML/Functions.html#method-c-boolean","(object=@@context[:node])",""],["build","REXML::Document","REXML/Document.html#method-i-build","( source )",""],["bytes","REXML::Child","REXML/Child.html#method-i-bytes","()","<p>This doesn&#39;t yet handle encodings\n"],["cdata","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-cdata","(content)","<p>Called when &lt;![CDATA[ … ]]&gt; is encountered in a document. @p content “…”\n"],["cdata","REXML::StreamListener","REXML/StreamListener.html#method-i-cdata","(content)","<p>Called when &lt;![CDATA[ … ]]&gt; is encountered in a document. @p content “…”\n"],["cdata?","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-cdata-3F","()","<p>Content: [ String text ]\n"],["cdatas","REXML::Element","REXML/Element.html#method-i-cdatas","()","<p>Get an array of all CData children. IMMUTABLE\n"],["ceiling","REXML::Functions","REXML/Functions.html#method-c-ceiling","( number )",""],["characters","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-characters","(text)",""],["check","REXML::Text","REXML/Text.html#method-c-check","(string, pattern, doctype)","<p>check for illegal characters\n"],["child","REXML::XPathParser","REXML/XPathParser.html#method-i-child","(nodeset)",""],["children","REXML::Light::Node","REXML/Light/Node.html#method-i-children","()",""],["children","REXML::Parent","REXML/Parent.html#method-i-children","()",""],["clear_cache","REXML::Text","REXML/Text.html#method-i-clear_cache","()",""],["clone","REXML::Attribute","REXML/Attribute.html#method-i-clone","()","<p>Returns a copy of this attribute\n"],["clone","REXML::CData","REXML/CData.html#method-i-clone","()","<p>Make a copy of this object\n<p><em>Examples</em>\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">c</span> = <span class=\"ruby-constant\">CData</span>.<span class=\"ruby-identifier\">new</span>( <span class=\"ruby-string\">&quot;Some text&quot;</span> )\n<span class=\"ruby-identifier\">d</span> = <span class=\"ruby-identifier\">c</span>.<span class=\"ruby-identifier\">clone</span>\n<span class=\"ruby-identifier\">d</span>.<span class=\"ruby-identifier\">to_s</span>        <span class=\"ruby-comment\"># -&gt; &quot;Some text&quot;</span>\n</pre>\n"],["clone","REXML::Comment","REXML/Comment.html#method-i-clone","()",""],["clone","REXML::DocType","REXML/DocType.html#method-i-clone","()",""],["clone","REXML::Document","REXML/Document.html#method-i-clone","()","<p>Should be obvious\n"],["clone","REXML::Element","REXML/Element.html#method-i-clone","()","<p>Creates a shallow copy of self.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span> = <span class=\"ruby-constant\">Document</span>.<span class=\"ruby-identifier\">new</span> <span class=\"ruby-string\">&quot;&lt;a&gt;&lt;b/&gt;&lt;b/&gt;&lt;c&gt;&lt;d/&gt;&lt;/c&gt;&lt;/a&gt;&quot;</span>\n<span class=\"ruby-identifier\">new_a</span> = <span class=\"ruby-identifier\">d</span>.<span class=\"ruby-identifier\">root</span>.<span class=\"ruby-identifier\">clone</span>\n<span class=\"ruby-identifier\">puts</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["clone","REXML::Instruction","REXML/Instruction.html#method-i-clone","()",""],["clone","REXML::Text","REXML/Text.html#method-i-clone","()",""],["clone","REXML::XMLDecl","REXML/XMLDecl.html#method-i-clone","()",""],["collect","REXML::Elements","REXML/Elements.html#method-i-collect","( xpath=nil )",""],["comment","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-comment","(comment)","<p>Called when a comment is encountered. @p comment The content of the comment\n"],["comment","REXML::StreamListener","REXML/StreamListener.html#method-i-comment","(comment)","<p>Called when a comment is encountered. @p comment The content of the comment\n"],["comment?","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-comment-3F","()","<p>Content: [ String text ]\n"],["comments","REXML::Element","REXML/Element.html#method-i-comments","()","<p>Get an array of all Comment children. IMMUTABLE\n"],["compare","REXML::XPathParser","REXML/XPathParser.html#method-i-compare","(a, operator, b)",""],["compare_language","REXML::Functions","REXML/Functions.html#method-c-compare_language","(lang1, lang2)",""],["concat","REXML::Functions","REXML/Functions.html#method-c-concat","( *objects )",""],["consume","REXML::IOSource","REXML/IOSource.html#method-i-consume","( pattern )",""],["consume","REXML::Source","REXML/Source.html#method-i-consume","( pattern )",""],["contains","REXML::Functions","REXML/Functions.html#method-c-contains","( string, test )","<p>Fixed by Mike Stok\n"],["content","REXML::XMLDecl","REXML/XMLDecl.html#method-i-content","(enc)",""],["context","REXML::DocType","REXML/DocType.html#method-i-context","()",""],["context","REXML::ParseException","REXML/ParseException.html#method-i-context","()",""],["context=","REXML::Functions","REXML/Functions.html#method-c-context-3D","(value)",""],["count","REXML::Functions","REXML/Functions.html#method-c-count","( node_set )","<p>Returns the size of the given list of nodes.\n"],["create_from","REXML::SourceFactory","REXML/SourceFactory.html#method-c-create_from","(arg)","<p>Generates a Source object @param arg Either a String, or an IO @return a Source, or nil if a bad argument …\n"],["current_line","REXML::IOSource","REXML/IOSource.html#method-i-current_line","()","<p>@return the current line in the source\n"],["current_line","REXML::Source","REXML/Source.html#method-i-current_line","()","<p>@return the current line in the source\n"],["dclone","Array","Array.html#method-i-dclone","()","<p>provides a unified <code>clone</code> operation, for REXML::XPathParser to use across multiple Object+ types\n"],["dclone","Float","Float.html#method-i-dclone","()","<p>provides a unified <code>clone</code> operation, for REXML::XPathParser to use across multiple Object types\n"],["dclone","Integer","Integer.html#method-i-dclone","()","<p>provides a unified <code>clone</code> operation, for REXML::XPathParser to use across multiple Object types\n"],["dclone","Object","Object.html#method-i-dclone","()","<p>provides a unified <code>clone</code> operation, for REXML::XPathParser to use across multiple Object types\n"],["dclone","Symbol","Symbol.html#method-i-dclone","()","<p>provides a unified <code>clone</code> operation, for REXML::XPathParser to use across multiple Object types\n"],["deafen","REXML::Parsers::SAX2Parser","REXML/Parsers/SAX2Parser.html#method-i-deafen","( listener=nil, &blok )",""],["decode","REXML::Encoding","REXML/Encoding.html#method-i-decode","(string)",""],["deep_clone","REXML::Parent","REXML/Parent.html#method-i-deep_clone","()","<p>Deeply clones this object.  This creates a complete duplicate of this Parent, including all descendants. …\n"],["default","REXML::XMLDecl","REXML/XMLDecl.html#method-c-default","()","<p>Only use this if you do not want the XML declaration to be written; this object is ignored by the XML …\n"],["delete","REXML::Attributes","REXML/Attributes.html#method-i-delete","( attribute )","<p>Removes an attribute\n<p>attribute &mdash; either a String, which is the name of the attribute to remove – namespaces …\n"],["delete","REXML::Elements","REXML/Elements.html#method-i-delete","(element)","<p>Deletes a child Element\n<p>element &mdash; Either an Element, which is removed directly; an xpath, where the first …\n"],["delete","REXML::Parent","REXML/Parent.html#method-i-delete","( object )",""],["delete_all","REXML::Attributes","REXML/Attributes.html#method-i-delete_all","( name )","<p>Deletes all attributes matching a name.  Namespaces are significant.\n<p>name &mdash; A String; all attributes that …\n"],["delete_all","REXML::Elements","REXML/Elements.html#method-i-delete_all","( xpath )","<p>Removes multiple elements.  Filters for Element children, regardless of XPath matching.\n<p>xpath &mdash; all elements …\n"],["delete_at","REXML::Parent","REXML/Parent.html#method-i-delete_at","( index )",""],["delete_attribute","REXML::Element","REXML/Element.html#method-i-delete_attribute","(key)","<p>Removes an attribute\n<p>key &mdash; either an Attribute or a String.  In either case, the attribute is found by matching …\n"],["delete_element","REXML::Element","REXML/Element.html#method-i-delete_element","(element)","<p>Deletes a child element.\n<p>element &mdash; Must be an <code>Element</code>, <code>String</code>, or <code>Integer</code>.  If Element, the element is removed. …\n"],["delete_if","REXML::Parent","REXML/Parent.html#method-i-delete_if","( &block )",""],["delete_namespace","REXML::Element","REXML/Element.html#method-i-delete_namespace","(namespace=\"xmlns\")","<p>Removes a namespace from this node.  This only works if the namespace is actually declared in this node. …\n"],["descendant","REXML::XPathParser","REXML/XPathParser.html#method-i-descendant","(nodeset, include_self)",""],["descendant_recursive","REXML::XPathParser","REXML/XPathParser.html#method-i-descendant_recursive","(raw_node, new_nodeset, new_nodes, include_self)",""],["detect_encoding","REXML::Source","REXML/Source.html#method-i-detect_encoding","()",""],["doctype","REXML::Attribute","REXML/Attribute.html#method-i-doctype","()",""],["doctype","REXML::Document","REXML/Document.html#method-i-doctype","()","<p>@return the DocType child of the document, if one exists, and nil otherwise.\n"],["doctype","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-doctype","(name, pub_sys, long_name, uri)","<p>Handles a doctype declaration. Any attributes of the doctype which are not supplied will be nil.  #  …\n"],["doctype","REXML::StreamListener","REXML/StreamListener.html#method-i-doctype","(name, pub_sys, long_name, uri)","<p>Handles a doctype declaration. Any attributes of the doctype which are not supplied will be nil.  #  …\n"],["doctype","REXML::Text","REXML/Text.html#method-i-doctype","()",""],["doctype?","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-doctype-3F","()","<p>Content: [ String name, String pub_sys, String long_name, String uri ]\n"],["doctype_end","REXML::StreamListener","REXML/StreamListener.html#method-i-doctype_end","()","<p>Called when the doctype is done\n"],["document","REXML::Child","REXML/Child.html#method-i-document","()","<p>Returns &mdash; the document this child belongs to, or nil if this child\n\n<p>belongs to no document\n"],["document","REXML::Document","REXML/Document.html#method-i-document","()",""],["document","REXML::Element","REXML/Element.html#method-i-document","()","<p>Evaluates to the document to which this element belongs, or nil if this element doesn&#39;t belong to …\n"],["done?","REXML::Validation::Event","REXML/Validation/Event.html#method-i-done-3F","()",""],["dowrite","REXML::XMLDecl","REXML/XMLDecl.html#method-i-dowrite","()",""],["dump","REXML::Validation::Validator","REXML/Validation/Validator.html#method-i-dump","()",""],["each","REXML::AttlistDecl","REXML/AttlistDecl.html#method-i-each","(&block)","<p>Iterate over the key/value pairs:\n\n<pre>attlist_decl.each { |attribute_name, attribute_value| ... }</pre>\n"],["each","REXML::Attributes","REXML/Attributes.html#method-i-each","()","<p>Iterates over each attribute of an Element, yielding the expanded name and value as a pair of Strings …\n"],["each","REXML::Elements","REXML/Elements.html#method-i-each","( xpath=nil )","<p>Iterates through all of the child Elements, optionally filtering them by a given XPath\n<p>xpath &mdash; optional. …\n\n"],["each","REXML::Light::Node","REXML/Light/Node.html#method-i-each","()",""],["each","REXML::Parent","REXML/Parent.html#method-i-each","(&block)",""],["each","REXML::Parsers::PullParser","REXML/Parsers/PullParser.html#method-i-each","()",""],["each","REXML::QuickPath","REXML/QuickPath.html#method-c-each","(element, path, namespaces=EMPTY_HASH, &block)",""],["each","REXML::XPath","REXML/XPath.html#method-c-each","(element, path=nil, namespaces=nil, variables={}, options={}, &block)","<p>Iterates over nodes that match the given path, calling the supplied block with the match.\n<p>element &mdash; The …\n"],["each_attribute","REXML::Attributes","REXML/Attributes.html#method-i-each_attribute","()","<p>Iterates over the attributes of an Element.  Yields actual Attribute nodes, not String values.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">doc</span> = <span class=\"ruby-constant\">Document</span>.<span class=\"ruby-identifier\">new</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["each_child","REXML::Parent","REXML/Parent.html#method-i-each_child","(&block)",""],["each_element","REXML::Element","REXML/Element.html#method-i-each_element","( xpath=nil )","<p>Synonym for Element.elements.each\n"],["each_element_with_attribute","REXML::Element","REXML/Element.html#method-i-each_element_with_attribute","( key, value=nil, max=0, name=nil )","<p>Iterates through the child elements, yielding for each Element that has a particular attribute set.\n<p>key … &mdash; "],["each_element_with_text","REXML::Element","REXML/Element.html#method-i-each_element_with_text","( text=nil, max=0, name=nil )","<p>Iterates through the children, yielding for each Element that has a particular text set.\n<p>text &mdash; the text …\n"],["each_index","REXML::Parent","REXML/Parent.html#method-i-each_index","( &block )",""],["each_recursive","REXML::Node","REXML/Node.html#method-i-each_recursive","()","<p>Visit all subnodes of <code>self</code> recursively\n"],["each_unnode","REXML::XPathParser","REXML/XPathParser.html#method-i-each_unnode","(nodeset)",""],["each_with_something","REXML::Element","REXML/Element.html#method-i-each_with_something","( test, max=0, name=nil )","<p>A private helper method\n"],["element=","REXML::Attribute","REXML/Attribute.html#method-i-element-3D","( element )","<p>Sets the element of which this object is an attribute.  Normally, this is not directly called.\n<p>Returns …\n"],["elementdecl","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-elementdecl","(content)","<p>&lt;!ELEMENT …&gt;\n"],["elementdecl","REXML::StreamListener","REXML/StreamListener.html#method-i-elementdecl","(content)","<p>&lt;!ELEMENT …&gt;\n"],["elementdecl?","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-elementdecl-3F","()","<p>Content: [ String text ]\n"],["empty?","REXML::Elements","REXML/Elements.html#method-i-empty-3F","()","<p>Returns <code>true</code> if there are no <code>Element</code> children, <code>false</code> otherwise\n"],["empty?","REXML::IOSource","REXML/IOSource.html#method-i-empty-3F","()",""],["empty?","REXML::Parsers::BaseParser","REXML/Parsers/BaseParser.html#method-i-empty-3F","()","<p>Returns true if there are no more events\n"],["empty?","REXML::Source","REXML/Source.html#method-i-empty-3F","()","<p>@return true if the Source is exhausted\n"],["empty?","REXML::Text","REXML/Text.html#method-i-empty-3F","()",""],["encode","REXML::Encoding","REXML/Encoding.html#method-i-encode","(string)",""],["encoding","REXML::Document","REXML/Document.html#method-i-encoding","()","<p>@return the XMLDecl encoding of this document as an Encoding object. If no XMLDecl has been set, returns …\n"],["encoding=","REXML::Encoding","REXML/Encoding.html#method-i-encoding-3D","(encoding)",""],["encoding=","REXML::Source","REXML/Source.html#method-i-encoding-3D","(enc)","<p>Inherited from Encoding Overridden to support optimized en/decoding\n"],["encoding=","REXML::XMLDecl","REXML/XMLDecl.html#method-i-encoding-3D","( enc )",""],["encoding_updated","REXML::IOSource","REXML/IOSource.html#method-i-encoding_updated","()",""],["encoding_updated","REXML::Source","REXML/Source.html#method-i-encoding_updated","()",""],["end_document","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-end_document","()",""],["end_element","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-end_element","(uri, localname, qname)",""],["end_element?","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-end_element-3F","()","<p>Content: [ String tag_name ]\n"],["end_prefix_mapping","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-end_prefix_mapping","(prefix)",""],["enter","REXML::XPathParser","REXML/XPathParser.html#method-i-enter","(tag, *args)",""],["entity","REXML::DocType","REXML/DocType.html#method-i-entity","( name )",""],["entity","REXML::Parsers::BaseParser","REXML/Parsers/BaseParser.html#method-i-entity","( reference, entities )",""],["entity","REXML::StreamListener","REXML/StreamListener.html#method-i-entity","(content)","<p>Called when %foo; is encountered in a doctype declaration. @p content “foo”\n"],["entity?","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-entity-3F","()","<p>Content: [ String text ]\n"],["entity_expansion_limit","REXML::Document","REXML/Document.html#method-c-entity_expansion_limit","()","<p>Get the entity expansion limit. By default the limit is set to 10000.\n<p>Deprecated. Use REXML::Security.entity_expansion_limit= …\n"],["entity_expansion_limit","REXML::Security","REXML/Security.html#method-c-entity_expansion_limit","()","<p>Get the entity expansion limit. By default the limit is set to 10000.\n"],["entity_expansion_limit=","REXML::Document","REXML/Document.html#method-c-entity_expansion_limit-3D","( val )","<p>Set the entity expansion limit. By default the limit is set to 10000.\n<p>Deprecated. Use REXML::Security.entity_expansion_limit= …\n"],["entity_expansion_limit=","REXML::Security","REXML/Security.html#method-c-entity_expansion_limit-3D","( val )","<p>Set the entity expansion limit. By default the limit is set to 10000.\n"],["entity_expansion_text_limit","REXML::Document","REXML/Document.html#method-c-entity_expansion_text_limit","()","<p>Get the entity expansion limit. By default the limit is set to 10240.\n<p>Deprecated. Use REXML::Security.entity_expansion_text_limit …\n"],["entity_expansion_text_limit","REXML::Security","REXML/Security.html#method-c-entity_expansion_text_limit","()","<p>Get the entity expansion limit. By default the limit is set to 10240.\n"],["entity_expansion_text_limit=","REXML::Document","REXML/Document.html#method-c-entity_expansion_text_limit-3D","( val )","<p>Set the entity expansion limit. By default the limit is set to 10240.\n<p>Deprecated. Use REXML::Security.entity_expansion_text_limit= …\n"],["entity_expansion_text_limit=","REXML::Security","REXML/Security.html#method-c-entity_expansion_text_limit-3D","( val )","<p>Set the entity expansion limit. By default the limit is set to 10240.\n"],["entitydecl","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-entitydecl","(declaration)","<p>&lt;!ENTITY …&gt; The argument passed to this method is an array of the entity declaration.  It can …\n"],["entitydecl","REXML::StreamListener","REXML/StreamListener.html#method-i-entitydecl","(content)","<p>&lt;!ENTITY …&gt; The argument passed to this method is an array of the entity declaration.  It can …\n"],["entitydecl?","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-entitydecl-3F","()","<p>Due to the wonders of DTDs, an entity declaration can be just about anything.  There&#39;s no way to …\n"],["equality_relational_compare","REXML::XPathParser","REXML/XPathParser.html#method-i-equality_relational_compare","(set1, op, set2)",""],["error?","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-error-3F","()",""],["evaluate_predicate","REXML::XPathParser","REXML/XPathParser.html#method-i-evaluate_predicate","(expression, nodesets)",""],["event_type","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-event_type","()",""],["expand","REXML::Parsers::XPathParser","REXML/Parsers/XPathParser.html#method-i-expand","( path )",""],["expand","REXML::Text","REXML/Text.html#method-c-expand","(ref, doctype, filter)",""],["expand_ref_in","REXML::Validation::State","REXML/Validation/State.html#method-i-expand_ref_in","( arry, ind )",""],["expanded_name","REXML::Document","REXML/Document.html#method-i-expanded_name","()","<p>According to the XML spec, a root node has no expanded name\n"],["expected","REXML::Validation::Choice","REXML/Validation/Choice.html#method-i-expected","()",""],["expected","REXML::Validation::Interleave","REXML/Validation/Interleave.html#method-i-expected","()",""],["expected","REXML::Validation::OneOrMore","REXML/Validation/OneOrMore.html#method-i-expected","()",""],["expected","REXML::Validation::Optional","REXML/Validation/Optional.html#method-i-expected","()",""],["expected","REXML::Validation::State","REXML/Validation/State.html#method-i-expected","()",""],["expected","REXML::Validation::ZeroOrMore","REXML/Validation/ZeroOrMore.html#method-i-expected","()",""],["expr","REXML::XPathParser","REXML/XPathParser.html#method-i-expr","( path_stack, nodeset, context=nil )","<p>Expr takes a stack of path elements and a set of nodes (either a Parent or an Array and returns an Array …\n"],["false","REXML::Functions","REXML/Functions.html#method-c-false","( )","<p>UNTESTED\n"],["filter","REXML::QuickPath","REXML/QuickPath.html#method-c-filter","(elements, path)","<p>Given an array of nodes it filters the array based on the path. The result is that when this method returns, …\n"],["filter_nodeset","REXML::XPathParser","REXML/XPathParser.html#method-i-filter_nodeset","(nodeset)",""],["find_encoding","REXML::Encoding","REXML/Encoding.html#method-i-find_encoding","(name)",""],["find_first_recursive","REXML::Node","REXML/Node.html#method-i-find_first_recursive","()","<p>Find (and return) first subnode (recursively) for which the block evaluates to true. Returns <code>nil</code> if none …\n"],["first","REXML::QuickPath","REXML/QuickPath.html#method-c-first","(element, path, namespaces=EMPTY_HASH)",""],["first","REXML::XPath","REXML/XPath.html#method-c-first","(element, path=nil, namespaces=nil, variables={}, options={})","<p>Finds and returns the first node that matches the supplied xpath.\n<p>element &mdash; The context element\n<p>path &mdash; The …\n"],["first","REXML::XPathParser","REXML/XPathParser.html#method-i-first","( path_stack, node )","<p>Performs a depth-first (document order) XPath search, and returns the first match.  This is the fastest, …\n"],["floor","REXML::Functions","REXML/Functions.html#method-c-floor","( number )",""],["following","REXML::XPathParser","REXML/XPathParser.html#method-i-following","(node)",""],["following_node_of","REXML::XPathParser","REXML/XPathParser.html#method-i-following_node_of","( node )",""],["fully_expanded_name","REXML::Namespace","REXML/Namespace.html#method-i-fully_expanded_name","()","<p>Fully expand the name, even if the prefix wasn&#39;t specified in the source file.\n"],["function","REXML::QuickPath","REXML/QuickPath.html#method-c-function","( elements, fname, rest )",""],["generate_event","REXML::Validation::State","REXML/Validation/State.html#method-i-generate_event","( event )",""],["get_attribute","REXML::Attributes","REXML/Attributes.html#method-i-get_attribute","( name )","<p>Fetches an attribute\n<p>name &mdash; the name by which to search for the attribute.  Can be a <code>prefix:name</code> namespace …\n"],["get_attribute_ns","REXML::Attributes","REXML/Attributes.html#method-i-get_attribute_ns","(namespace, name)","<p>The <code>get_attribute_ns</code> method retrieves a method by its namespace and name. Thus it is possible to reliably …\n"],["get_elements","REXML::Element","REXML/Element.html#method-i-get_elements","( xpath )","<p>Synonym for Element.to_a This is a little slower than calling elements.each directly.\n<p>xpath &mdash; any XPath …\n"],["get_first","REXML::XPathParser","REXML/XPathParser.html#method-i-get_first","(path, nodeset)",""],["get_group","REXML::Parsers::XPathParser","REXML/Parsers/XPathParser.html#method-i-get_group","(string)","<p>get_group( &#39;[foo]bar&#39; ) -&gt; [&#39;bar&#39;, &#39;[foo]&#39;]\n"],["get_listeners","REXML::Parsers::SAX2Parser","REXML/Parsers/SAX2Parser.html#method-i-get_listeners","( symbol, name )",""],["get_namespace","REXML::Functions","REXML/Functions.html#method-c-get_namespace","( node_set = nil )","<p>Helper method.\n"],["get_namespace","REXML::Parsers::SAX2Parser","REXML/Parsers/SAX2Parser.html#method-i-get_namespace","( prefix )",""],["get_namespace","REXML::XPathParser","REXML/XPathParser.html#method-i-get_namespace","( node, prefix )","<p>Returns a String namespace for a node, given a prefix The rules are:\n\n<pre class=\"ruby\"><span class=\"ruby-value\">1</span>. <span class=\"ruby-constant\">Use</span> <span class=\"ruby-identifier\">the</span> <span class=\"ruby-identifier\">supplied</span> <span class=\"ruby-identifier\">namespace</span> <span class=\"ruby-identifier\">mapping</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["get_procs","REXML::Parsers::SAX2Parser","REXML/Parsers/SAX2Parser.html#method-i-get_procs","( symbol, name )","<p>The following methods are duplicates, but it is faster than using a helper\n"],["get_text","REXML::Element","REXML/Element.html#method-i-get_text","(path = nil)","<p>Returns the first child Text node, if any, or <code>nil</code> otherwise. This method returns the actual <code>Text</code> node, …\n"],["handle","REXML::Parsers::SAX2Parser","REXML/Parsers/SAX2Parser.html#method-i-handle","( symbol, *arguments )",""],["handle_entitydecl","REXML::Parsers::SAX2Parser","REXML/Parsers/SAX2Parser.html#method-i-handle_entitydecl","( event )",""],["has_attributes?","REXML::Element","REXML/Element.html#method-i-has_attributes-3F","()","<p>Evaluates to <code>true</code> if this element has any attributes set, false otherwise.\n"],["has_elements?","REXML::Element","REXML/Element.html#method-i-has_elements-3F","()","<p>Evaluates to <code>true</code> if this element has at least one child Element\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">doc</span> = <span class=\"ruby-constant\">Document</span>.<span class=\"ruby-identifier\">new</span> <span class=\"ruby-string\">&quot;&lt;a&gt;&lt;b/&gt;&lt;c&gt;Text&lt;/c&gt;&lt;/a&gt;&quot;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["has_name?","REXML::Light::Node","REXML/Light/Node.html#method-i-has_name-3F","( name, namespace = '' )",""],["has_name?","REXML::Namespace","REXML/Namespace.html#method-i-has_name-3F","( other, ns=nil )","<p>Compares names optionally WITH namespaces\n"],["has_next?","REXML::Parsers::BaseParser","REXML/Parsers/BaseParser.html#method-i-has_next-3F","()","<p>Returns true if there are more events.  Synonymous with !empty?\n"],["has_text?","REXML::Element","REXML/Element.html#method-i-has_text-3F","()","<p>Evaluates to <code>true</code> if this element has at least one Text child\n"],["hash","REXML::Attribute","REXML/Attribute.html#method-i-hash","()","<p>Creates (and returns) a hash from both the name and value\n"],["id","REXML::Functions","REXML/Functions.html#method-c-id","( object )","<p>Since REXML is non-validating, this method is not implemented as it requires a DTD\n"],["ignore_whitespace_nodes","REXML::Element","REXML/Element.html#method-i-ignore_whitespace_nodes","()",""],["include?","REXML::AttlistDecl","REXML/AttlistDecl.html#method-i-include-3F","(key)","<p>Whether an attlist declaration includes the given attribute definition\n\n<pre>if attlist_decl.include? &quot;xmlns:foobar&quot;</pre>\n"],["indent","REXML::Node","REXML/Node.html#method-i-indent","(to, ind)",""],["indent_text","REXML::Formatters::Pretty","REXML/Formatters/Pretty.html#method-i-indent_text","(string, level=1, style=\"\\t\", indentfirstline=true)",""],["indent_text","REXML::Text","REXML/Text.html#method-i-indent_text","(string, level=1, style=\"\\t\", indentfirstline=true)",""],["index","REXML::Elements","REXML/Elements.html#method-i-index","(element)","<p>Returns the index of the supplied child (starting at 1), or -1 if the element is not a child\n<p>element &mdash; "],["index","REXML::Parent","REXML/Parent.html#method-i-index","( child )","<p>Fetches the index of a given child @param child the child to get the index of @return the index of the …\n"],["index_in_parent","REXML::Node","REXML/Node.html#method-i-index_in_parent","()","<p>Returns the position that <code>self</code> holds in its parent&#39;s array, indexed from 1.\n"],["inject","REXML::Elements","REXML/Elements.html#method-i-inject","( xpath=nil, initial=nil )",""],["insert_after","REXML::Parent","REXML/Parent.html#method-i-insert_after","( child1, child2 )","<p>Inserts an child after another child @param child1 this is either an xpath or an Element.  If an Element …\n"],["insert_before","REXML::Parent","REXML/Parent.html#method-i-insert_before","( child1, child2 )","<p>Inserts an child before another child @param child1 this is either an xpath or an Element.  If an Element …\n"],["inspect","REXML::Attribute","REXML/Attribute.html#method-i-inspect","()",""],["inspect","REXML::Element","REXML/Element.html#method-i-inspect","()",""],["inspect","REXML::Instruction","REXML/Instruction.html#method-i-inspect","()",""],["inspect","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-inspect","()",""],["inspect","REXML::Text","REXML/Text.html#method-i-inspect","()",""],["inspect","REXML::Validation::Choice","REXML/Validation/Choice.html#method-i-inspect","()",""],["inspect","REXML::Validation::Event","REXML/Validation/Event.html#method-i-inspect","()",""],["inspect","REXML::Validation::Interleave","REXML/Validation/Interleave.html#method-i-inspect","()",""],["inspect","REXML::Validation::Ref","REXML/Validation/Ref.html#method-i-inspect","()",""],["inspect","REXML::Validation::State","REXML/Validation/State.html#method-i-inspect","()",""],["inspect","REXML::XMLDecl","REXML/XMLDecl.html#method-i-inspect","()",""],["instruction","REXML::StreamListener","REXML/StreamListener.html#method-i-instruction","(name, instruction)","<p>Called when an instruction is encountered.  EG: &lt;?xsl sheet=&#39;foo&#39;?&gt; @p name the instruction …\n"],["instruction?","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-instruction-3F","()","<p>Content: [ String text ]\n"],["instructions","REXML::Element","REXML/Element.html#method-i-instructions","()","<p>Get an array of all Instruction children. IMMUTABLE\n"],["lang","REXML::Functions","REXML/Functions.html#method-c-lang","( language )","<p>UNTESTED\n"],["last","REXML::Functions","REXML/Functions.html#method-c-last","( )","<p>Returns the last node of the given list of nodes.\n"],["leave","REXML::XPathParser","REXML/XPathParser.html#method-i-leave","(tag, *args)",""],["length","REXML::Attributes","REXML/Attributes.html#method-i-length","()","<p>Returns the number of attributes the owning Element contains.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">doc</span> = <span class=\"ruby-constant\">Document</span> <span class=\"ruby-string\">&quot;&lt;a x=&#39;1&#39; y=&#39;2&#39; foo:x=&#39;3&#39;/&gt;&quot;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["length","REXML::Parent","REXML/Parent.html#method-i-length","()",""],["line","REXML::ParseException","REXML/ParseException.html#method-i-line","()",""],["listen","REXML::Parsers::SAX2Parser","REXML/Parsers/SAX2Parser.html#method-i-listen","( *args, &blok )","<p>Listen arguments:\n<p>Symbol, Array, Block\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Listen</span> <span class=\"ruby-identifier\">to</span> <span class=\"ruby-constant\">Symbol</span> <span class=\"ruby-identifier\">events</span> <span class=\"ruby-identifier\">on</span> <span class=\"ruby-constant\">Array</span> <span class=\"ruby-identifier\">elements</span>\n</pre>\n"],["literalize","REXML::Elements","REXML/Elements.html#method-i-literalize","(name)","<p>Private helper class.  Removes quotes from quoted strings\n"],["local_name","REXML::Functions","REXML/Functions.html#method-c-local_name","(node_set=nil)",""],["local_name","REXML::Light::Node","REXML/Light/Node.html#method-i-local_name","()",""],["local_name=","REXML::Light::Node","REXML/Light/Node.html#method-i-local_name-3D","( name_str )",""],["match","REXML::IOSource","REXML/IOSource.html#method-i-match","( pattern, cons=false )",""],["match","REXML::QuickPath","REXML/QuickPath.html#method-c-match","(element, path, namespaces=EMPTY_HASH)",""],["match","REXML::Source","REXML/Source.html#method-i-match","(pattern, cons=false)",""],["match","REXML::XPath","REXML/XPath.html#method-c-match","(element, path=nil, namespaces=nil, variables={}, options={})","<p>Returns an array of nodes matching a given XPath.\n"],["match","REXML::XPathParser","REXML/XPathParser.html#method-i-match","(path_stack, nodeset)",""],["match_to","REXML::Source","REXML/Source.html#method-i-match_to","( char, pattern )",""],["match_to_consume","REXML::Source","REXML/Source.html#method-i-match_to_consume","( char, pattern )",""],["matches?","REXML::Entity","REXML/Entity.html#method-c-matches-3F","(string)","<p>Evaluates whether the given string matches an entity definition, returning true if so, and false otherwise. …\n"],["matches?","REXML::Validation::Choice","REXML/Validation/Choice.html#method-i-matches-3F","( event )",""],["matches?","REXML::Validation::Event","REXML/Validation/Event.html#method-i-matches-3F","( event )",""],["matches?","REXML::Validation::Interleave","REXML/Validation/Interleave.html#method-i-matches-3F","( event )",""],["matches?","REXML::Validation::OneOrMore","REXML/Validation/OneOrMore.html#method-i-matches-3F","( event )",""],["matches?","REXML::Validation::Optional","REXML/Validation/Optional.html#method-i-matches-3F","(event)",""],["matches?","REXML::Validation::Sequence","REXML/Validation/Sequence.html#method-i-matches-3F","(event)",""],["method_missing","REXML::QuickPath","REXML/QuickPath.html#method-c-method_missing","( id, *args )",""],["name","REXML::Document","REXML/Document.html#method-i-name","()",""],["name","REXML::Functions","REXML/Functions.html#method-c-name","( node_set=nil )",""],["name","REXML::Light::Node","REXML/Light/Node.html#method-i-name","()",""],["name","REXML::NotationDecl","REXML/NotationDecl.html#method-i-name","()","<p>This method retrieves the name of the notation.\n<p>Method contributed by Henrik Martensson\n"],["name","REXML::QuickPath","REXML/QuickPath.html#method-c-name","()",""],["name=","REXML::Light::Node","REXML/Light/Node.html#method-i-name-3D","( name_str, ns=nil )",""],["name=","REXML::Namespace","REXML/Namespace.html#method-i-name-3D","( name )","<p>Sets the name and the expanded name\n"],["namespace","REXML::Attribute","REXML/Attribute.html#method-i-namespace","(arg=nil)","<p>Returns the namespace URL, if defined, or nil otherwise\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">e</span> = <span class=\"ruby-constant\">Element</span>.<span class=\"ruby-identifier\">new</span>(<span class=\"ruby-string\">&quot;el&quot;</span>)\n<span class=\"ruby-identifier\">e</span>.<span class=\"ruby-identifier\">add_namespace</span>(<span class=\"ruby-string\">&quot;ns&quot;</span>, <span class=\"ruby-string\">&quot;http://url&quot;</span>) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["namespace","REXML::Element","REXML/Element.html#method-i-namespace","(prefix=nil)","<p>Evaluates to the URI for a prefix, or the empty string if no such namespace is declared for this element. …\n"],["namespace","REXML::Light::Node","REXML/Light/Node.html#method-i-namespace","( prefix=prefix() )",""],["namespace=","REXML::Light::Node","REXML/Light/Node.html#method-i-namespace-3D","( namespace )",""],["namespace_context","REXML::Functions","REXML/Functions.html#method-c-namespace_context","()",""],["namespace_context=","REXML::Functions","REXML/Functions.html#method-c-namespace_context-3D","(x)",""],["namespace_of","REXML::Light::Node","REXML/Light/Node.html#method-i-namespace_of","( node, prefix=nil )",""],["namespace_uri","REXML::Functions","REXML/Functions.html#method-c-namespace_uri","( node_set=nil )",""],["namespaces","REXML::Attributes","REXML/Attributes.html#method-i-namespaces","()",""],["namespaces","REXML::Element","REXML/Element.html#method-i-namespaces","()",""],["namespaces=","REXML::Parsers::XPathParser","REXML/Parsers/XPathParser.html#method-i-namespaces-3D","( namespaces )",""],["namespaces=","REXML::XPathParser","REXML/XPathParser.html#method-i-namespaces-3D","( namespaces={} )",""],["namesplit","REXML::Light::Node","REXML/Light/Node.html#method-i-namesplit","()",""],["need_source_encoding_update?","REXML::Parsers::BaseParser","REXML/Parsers/BaseParser.html#method-i-need_source_encoding_update-3F","(xml_declaration_encoding)",""],["new","REXML::AttlistDecl","REXML/AttlistDecl.html#method-c-new","(source)","<p>Create an AttlistDecl, pulling the information from a Source.  Notice that this isn&#39;t very convenient; …\n"],["new","REXML::Attribute","REXML/Attribute.html#method-c-new","( first, second=nil, parent=nil )","<p>Constructor. FIXME: The parser doesn&#39;t catch illegal characters in attributes\n<p>first &mdash; Either: an Attribute …\n"],["new","REXML::Attributes","REXML/Attributes.html#method-c-new","(element)","<p>Constructor\n<p>element &mdash; the Element of which this is an Attribute\n\n"],["new","REXML::CData","REXML/CData.html#method-c-new","( first, whitespace=true, parent=nil )","\n<pre>Constructor.  CData is data between &lt;![CDATA[ ... ]]&gt;</pre>\n<p><em>Examples</em>\n\n<pre>CData.new( source )\nCData.new( &quot;Here is ...</pre>\n"],["new","REXML::Child","REXML/Child.html#method-c-new","( parent = nil )","<p>Constructor.  Any inheritors of this class should call super to make sure this method is called.\n<p>parent … &mdash; "],["new","REXML::Comment","REXML/Comment.html#method-c-new","( first, second = nil )","<p>Constructor.  The first argument can be one of three types: @param first If String, the contents of this …\n"],["new","REXML::DTD::ElementDecl","REXML/DTD/ElementDecl.html#method-c-new","(match)","<p>s*(((([“‘]).*?5)|*)*?)(/)?&gt;/um, true)\n"],["new","REXML::DTD::EntityDecl","REXML/DTD/EntityDecl.html#method-c-new","(src)","<p>&lt;!ENTITY name SYSTEM “…”&gt; &lt;!ENTITY name “…”&gt;\n"],["new","REXML::DTD::NotationDecl","REXML/DTD/NotationDecl.html#method-c-new","(src)",""],["new","REXML::Declaration","REXML/Declaration.html#method-c-new","(src)",""],["new","REXML::DocType","REXML/DocType.html#method-c-new","( first, parent=nil )","<p>Constructor\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">dt</span> = <span class=\"ruby-constant\">DocType</span>.<span class=\"ruby-identifier\">new</span>( <span class=\"ruby-string\">&#39;foo&#39;</span>, <span class=\"ruby-string\">&#39;-//I/Hate/External/IDs&#39;</span> )\n<span class=\"ruby-comment\"># &lt;!DOCTYPE foo &#39;-//I/Hate/External/IDs&#39;&gt; ...</span>\n</pre>\n"],["new","REXML::Document","REXML/Document.html#method-c-new","( source = nil, context = {} )","<p>Constructor @param source if supplied, must be a Document, String, or IO. Documents have their context …\n"],["new","REXML::Element","REXML/Element.html#method-c-new","( arg = UNDEFINED, parent=nil, context=nil )","<p>Constructor\n<p>arg &mdash; if not supplied, will be set to the default value. If a String, the name of this object …\n"],["new","REXML::ElementDecl","REXML/ElementDecl.html#method-c-new","( src )",""],["new","REXML::Elements","REXML/Elements.html#method-c-new","(parent)","<p>Constructor\n<p>parent &mdash; the parent Element\n\n"],["new","REXML::Entity","REXML/Entity.html#method-c-new","(stream, value=nil, parent=nil, reference=false)","<p>Create a new entity.  Simple entities can be constructed by passing a name, value to the constructor; …\n"],["new","REXML::ExternalEntity","REXML/ExternalEntity.html#method-c-new","( src )",""],["new","REXML::Formatters::Default","REXML/Formatters/Default.html#method-c-new","( ie_hack=false )","<p>Prints out the XML document with no formatting – except if ie_hack is set.\n<p>ie_hack &mdash; If set to true, then …\n\n"],["new","REXML::Formatters::Pretty","REXML/Formatters/Pretty.html#method-c-new","( indentation=2, ie_hack=false )","<p>Create a new pretty printer.\n<p>output &mdash; An object implementing &#39;&lt;&lt;(String)&#39;, to which the output …\n"],["new","REXML::Formatters::Transitive","REXML/Formatters/Transitive.html#method-c-new","( indentation=2, ie_hack=false )",""],["new","REXML::IOSource","REXML/IOSource.html#method-c-new","(arg, block_size=500, encoding=nil)","<p>block_size has been deprecated\n"],["new","REXML::Instruction","REXML/Instruction.html#method-c-new","(target, content=nil)","<p>Constructs a new Instruction @param target can be one of a number of things.  If String, then the target …\n"],["new","REXML::Light::Node","REXML/Light/Node.html#method-c-new","(node=nil)","<p>Create a new element.\n"],["new","REXML::NotationDecl","REXML/NotationDecl.html#method-c-new","(name, middle, pub, sys)",""],["new","REXML::Output","REXML/Output.html#method-c-new","(real_IO, encd=\"iso-8859-1\")",""],["new","REXML::Parent","REXML/Parent.html#method-c-new","(parent=nil)","<p>Constructor @param parent if supplied, will be set as the parent of this object\n"],["new","REXML::ParseException","REXML/ParseException.html#method-c-new","( message, source=nil, parser=nil, exception=nil )",""],["new","REXML::Parsers::BaseParser","REXML/Parsers/BaseParser.html#method-c-new","( source )",""],["new","REXML::Parsers::LightParser","REXML/Parsers/LightParser.html#method-c-new","(stream)",""],["new","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-c-new","(arg)","<p>The type of this event.  Will be one of :tag_start, :tag_end, :text, :processing_instruction, :comment, …\n"],["new","REXML::Parsers::PullParser","REXML/Parsers/PullParser.html#method-c-new","(stream)",""],["new","REXML::Parsers::SAX2Parser","REXML/Parsers/SAX2Parser.html#method-c-new","(source)",""],["new","REXML::Parsers::StreamParser","REXML/Parsers/StreamParser.html#method-c-new","(source, listener)",""],["new","REXML::Parsers::TreeParser","REXML/Parsers/TreeParser.html#method-c-new","( source, build_context = Document.new )",""],["new","REXML::Parsers::UltraLightParser","REXML/Parsers/UltraLightParser.html#method-c-new","(stream)",""],["new","REXML::Source","REXML/Source.html#method-c-new","(arg, encoding=nil)","<p>Constructor @param arg must be a String, and should be a valid XML document @param encoding if non-null, …\n"],["new","REXML::Text","REXML/Text.html#method-c-new","(arg, respect_whitespace=false, parent=nil, raw=nil, entity_filter=nil, illegal=NEEDS_A_SECOND_CHECK )","<p>Constructor <code>arg</code> if a String, the content is set to the String.  If a Text, the object is shallowly cloned. …\n"],["new","REXML::UndefinedNamespaceException","REXML/UndefinedNamespaceException.html#method-c-new","( prefix, source, parser )",""],["new","REXML::Validation::Choice","REXML/Validation/Choice.html#method-c-new","(context)",""],["new","REXML::Validation::Event","REXML/Validation/Event.html#method-c-new","(event_type, event_arg=nil )",""],["new","REXML::Validation::Interleave","REXML/Validation/Interleave.html#method-c-new","(context)",""],["new","REXML::Validation::OneOrMore","REXML/Validation/OneOrMore.html#method-c-new","(context)",""],["new","REXML::Validation::Ref","REXML/Validation/Ref.html#method-c-new","(value)",""],["new","REXML::Validation::RelaxNG","REXML/Validation/RelaxNG.html#method-c-new","(source)","<p>FIXME: Namespaces\n"],["new","REXML::Validation::State","REXML/Validation/State.html#method-c-new","( context )",""],["new","REXML::Validation::ValidationException","REXML/Validation/ValidationException.html#method-c-new","(msg)",""],["new","REXML::XMLDecl","REXML/XMLDecl.html#method-c-new","(version=DEFAULT_VERSION, encoding=nil, standalone=nil)",""],["new","REXML::XPathNode","REXML/XPathNode.html#method-c-new","(node, context=nil)",""],["new","REXML::XPathParser","REXML/XPathParser.html#method-c-new","(strict: false)",""],["next","REXML::Validation::Choice","REXML/Validation/Choice.html#method-i-next","( event )",""],["next","REXML::Validation::Interleave","REXML/Validation/Interleave.html#method-i-next","( event )",""],["next","REXML::Validation::OneOrMore","REXML/Validation/OneOrMore.html#method-i-next","( event )",""],["next","REXML::Validation::Optional","REXML/Validation/Optional.html#method-i-next","( event )",""],["next","REXML::Validation::State","REXML/Validation/State.html#method-i-next","( event )",""],["next","REXML::Validation::ZeroOrMore","REXML/Validation/ZeroOrMore.html#method-i-next","( event )",""],["next_current","REXML::Validation::Interleave","REXML/Validation/Interleave.html#method-i-next_current","( event )",""],["next_element","REXML::Element","REXML/Element.html#method-i-next_element","()","<p>Returns the next sibling that is an element, or nil if there is no Element sibling after this one\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">doc</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["next_sibling=","REXML::Child","REXML/Child.html#method-i-next_sibling-3D","( other )","<p>Sets the next sibling of this child.  This can be used to insert a child after some other child.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">a</span> = <span class=\"ruby-constant\">Element</span>.<span class=\"ruby-identifier\">new</span>(<span class=\"ruby-string\">&quot;a&quot;</span>) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["next_sibling_node","REXML::Node","REXML/Node.html#method-i-next_sibling_node","()","<p>@return the next sibling (nil if unset)\n"],["next_sibling_node","REXML::XPathParser","REXML/XPathParser.html#method-i-next_sibling_node","(node)",""],["node_test","REXML::XPathParser","REXML/XPathParser.html#method-i-node_test","(path_stack, nodesets, any_type: :element)",""],["node_type","REXML::AttlistDecl","REXML/AttlistDecl.html#method-i-node_type","()",""],["node_type","REXML::Attribute","REXML/Attribute.html#method-i-node_type","()",""],["node_type","REXML::Comment","REXML/Comment.html#method-i-node_type","()",""],["node_type","REXML::DocType","REXML/DocType.html#method-i-node_type","()",""],["node_type","REXML::Document","REXML/Document.html#method-i-node_type","()",""],["node_type","REXML::Element","REXML/Element.html#method-i-node_type","()",""],["node_type","REXML::Instruction","REXML/Instruction.html#method-i-node_type","()",""],["node_type","REXML::Light::Node","REXML/Light/Node.html#method-i-node_type","()",""],["node_type","REXML::Text","REXML/Text.html#method-i-node_type","()",""],["node_type","REXML::XMLDecl","REXML/XMLDecl.html#method-i-node_type","()",""],["norm","REXML::XPathParser","REXML/XPathParser.html#method-i-norm","(b)",""],["normalize","REXML::Parsers::BaseParser","REXML/Parsers/BaseParser.html#method-i-normalize","( input, entities=nil, entity_filter=nil )","<p>Escapes all possible entities\n"],["normalize","REXML::Text","REXML/Text.html#method-c-normalize","( input, doctype=nil, entity_filter=nil )","<p>Escapes all possible entities\n"],["normalize_compare_values","REXML::XPathParser","REXML/XPathParser.html#method-i-normalize_compare_values","(a, operator, b)",""],["normalize_space","REXML::Functions","REXML/Functions.html#method-c-normalize_space","( string=nil )","<p>UNTESTED\n"],["normalized","REXML::Entity","REXML/Entity.html#method-i-normalized","()","<p>Returns the value of this entity unprocessed – raw.  This is the normalized value; that is, with all …\n"],["not","REXML::Functions","REXML/Functions.html#method-c-not","( object )","<p>UNTESTED\n"],["notation","REXML::DocType","REXML/DocType.html#method-i-notation","(name)","<p>Retrieves a named notation. Only notations declared in the internal DTD subset can be retrieved.\n<p>Method …\n"],["notationdecl","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-notationdecl","(name, public_or_system, public_id, system_id)","<p>&lt;!NOTATION …&gt;\n"],["notationdecl","REXML::StreamListener","REXML/StreamListener.html#method-i-notationdecl","(content)","<p>&lt;!NOTATION …&gt;\n"],["notationdecl?","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-notationdecl-3F","()","<p>Content: [ String text ]\n"],["notations","REXML::DocType","REXML/DocType.html#method-i-notations","()","<p>This method returns a list of notations that have been declared in the <em>internal</em> DTD subset. Notations …\n"],["nowrite","REXML::XMLDecl","REXML/XMLDecl.html#method-i-nowrite","()",""],["number","REXML::Functions","REXML/Functions.html#method-c-number","(object=@@context[:node])","<p>a string that consists of optional whitespace followed by an optional minus sign followed by a Number …\n"],["old_enc=","REXML::XMLDecl","REXML/XMLDecl.html#method-i-old_enc-3D","( enc )",""],["parent","REXML::Light::Node","REXML/Light/Node.html#method-i-parent","()",""],["parent=","REXML::Child","REXML/Child.html#method-i-parent-3D","( other )","<p>Sets the parent of this child to the supplied argument.\n<p>other &mdash; Must be a Parent object.  If this object …\n"],["parent=","REXML::Light::Node","REXML/Light/Node.html#method-i-parent-3D","( node )",""],["parent=","REXML::Text","REXML/Text.html#method-i-parent-3D","(parent)",""],["parent?","REXML::Node","REXML/Node.html#method-i-parent-3F","()",""],["parent?","REXML::Parent","REXML/Parent.html#method-i-parent-3F","()",""],["parse","REXML::DTD::Parser","REXML/DTD/Parser.html#method-c-parse","( input )",""],["parse","REXML::Parsers::LightParser","REXML/Parsers/LightParser.html#method-i-parse","()",""],["parse","REXML::Parsers::SAX2Parser","REXML/Parsers/SAX2Parser.html#method-i-parse","()",""],["parse","REXML::Parsers::StreamParser","REXML/Parsers/StreamParser.html#method-i-parse","()",""],["parse","REXML::Parsers::TreeParser","REXML/Parsers/TreeParser.html#method-i-parse","()",""],["parse","REXML::Parsers::UltraLightParser","REXML/Parsers/UltraLightParser.html#method-i-parse","()",""],["parse","REXML::Parsers::XPathParser","REXML/Parsers/XPathParser.html#method-i-parse","(path)",""],["parse","REXML::XPathParser","REXML/XPathParser.html#method-i-parse","(path, nodeset)",""],["parse_args","REXML::Parsers::XPathParser","REXML/Parsers/XPathParser.html#method-i-parse_args","( string )",""],["parse_args","REXML::QuickPath","REXML/QuickPath.html#method-c-parse_args","( element, string )",""],["parse_attributes","REXML::Parsers::BaseParser","REXML/Parsers/BaseParser.html#method-i-parse_attributes","(prefixes, curr_ns)",""],["parse_helper","REXML::DTD::Parser","REXML/DTD/Parser.html#method-c-parse_helper","( input )","<p>Takes a String and parses it out\n"],["parse_source","REXML::DTD::EntityDecl","REXML/DTD/EntityDecl.html#method-c-parse_source","(source, listener)",""],["parse_source","REXML::DTD::NotationDecl","REXML/DTD/NotationDecl.html#method-c-parse_source","(source, listener)",""],["parse_stream","REXML::Document","REXML/Document.html#method-c-parse_stream","( source, listener )",""],["peek","REXML::Parsers::BaseParser","REXML/Parsers/BaseParser.html#method-i-peek","(depth=0)","<p>Peek at the <code>depth</code> event in the stack.  The first element on the stack is at depth 0.  If <code>depth</code> is -1, …\n"],["peek","REXML::Parsers::PullParser","REXML/Parsers/PullParser.html#method-i-peek","(depth=0)",""],["position","REXML::Functions","REXML/Functions.html#method-c-position","( )",""],["position","REXML::IOSource","REXML/IOSource.html#method-i-position","()",""],["position","REXML::ParseException","REXML/ParseException.html#method-i-position","()",""],["position","REXML::Parsers::BaseParser","REXML/Parsers/BaseParser.html#method-i-position","()",""],["position","REXML::Source","REXML/Source.html#method-i-position","()",""],["position","REXML::XPathNode","REXML/XPathNode.html#method-i-position","()",""],["preceding","REXML::XPathParser","REXML/XPathParser.html#method-i-preceding","(node)","<p>Builds a nodeset of all of the preceding nodes of the supplied node, in reverse document order\n<p>preceding … &mdash; "],["preceding_node_of","REXML::XPathParser","REXML/XPathParser.html#method-i-preceding_node_of","( node )",""],["predicate","REXML::Parsers::XPathParser","REXML/Parsers/XPathParser.html#method-i-predicate","(path)",""],["predicate","REXML::QuickPath","REXML/QuickPath.html#method-c-predicate","( elements, path )","<p>A predicate filters a node-set with respect to an axis to produce a new node-set. For each node in the …\n"],["predicate","REXML::XPathParser","REXML/XPathParser.html#method-i-predicate","(path, nodeset)",""],["predicate_to_string","REXML::Parsers::XPathParser","REXML/Parsers/XPathParser.html#method-i-predicate_to_string","( path, &block )",""],["prefix","REXML::Attribute","REXML/Attribute.html#method-i-prefix","()","<p>Returns the namespace of the attribute.\n\n<pre>e = Element.new( &quot;elns:myelement&quot; )\ne.add_attribute( &quot;nsa:a&quot;, ...</pre>\n"],["prefix","REXML::Light::Node","REXML/Light/Node.html#method-i-prefix","( namespace=nil )",""],["prefix_of","REXML::Light::Node","REXML/Light/Node.html#method-i-prefix_of","( node, namespace=nil )",""],["prefixes","REXML::Attributes","REXML/Attributes.html#method-i-prefixes","()","<p>Returns an array of Strings containing all of the prefixes declared by this set of # attributes.  The …\n"],["prefixes","REXML::Element","REXML/Element.html#method-i-prefixes","()","<p>Evaluates to an <code>Array</code> containing the prefixes (names) of all defined namespaces at this context node. …\n"],["previous=","REXML::Validation::State","REXML/Validation/State.html#method-i-previous-3D","( previous )",""],["previous_element","REXML::Element","REXML/Element.html#method-i-previous_element","()","<p>Returns the previous sibling that is an element, or nil if there is no Element sibling prior to this …\n"],["previous_sibling=","REXML::Child","REXML/Child.html#method-i-previous_sibling-3D","(other)","<p>Sets the previous sibling of this child.  This can be used to insert a child before some other child. …\n"],["previous_sibling_node","REXML::Node","REXML/Node.html#method-i-previous_sibling_node","()","<p>@return the previous sibling (nil if unset)\n"],["process_instruction","REXML::Parsers::BaseParser","REXML/Parsers/BaseParser.html#method-i-process_instruction","()",""],["processing_instruction","REXML::Functions","REXML/Functions.html#method-c-processing_instruction","( node )",""],["processing_instruction","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-processing_instruction","(target, data)",""],["progress","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-progress","(position)",""],["public","REXML::DocType","REXML/DocType.html#method-i-public","()","<p>This method retrieves the public identifier identifying the document&#39;s DTD.\n<p>Method contributed by …\n"],["pull","REXML::Parsers::BaseParser","REXML/Parsers/BaseParser.html#method-i-pull","()","<p>Returns the next event.  This is a <code>PullEvent</code> object.\n"],["pull","REXML::Parsers::PullParser","REXML/Parsers/PullParser.html#method-i-pull","()",""],["pull_event","REXML::Parsers::BaseParser","REXML/Parsers/BaseParser.html#method-i-pull_event","()",""],["push","REXML::Parent","REXML/Parent.html#method-i-push","( object )",""],["raw","REXML::Element","REXML/Element.html#method-i-raw","()","<p>Evaluates to <code>true</code> if raw mode is set for this element.  This is the case if the context has :<code>raw</code> set …\n"],["read","REXML::IOSource","REXML/IOSource.html#method-i-read","()",""],["read","REXML::Source","REXML/Source.html#method-i-read","()",""],["read_with_substitution","REXML::Text","REXML/Text.html#method-c-read_with_substitution","( input, illegal=nil )","<p>Reads text, substituting entities\n"],["readline","REXML::IOSource","REXML/IOSource.html#method-i-readline","()",""],["receive","REXML::Validation::RelaxNG","REXML/Validation/RelaxNG.html#method-i-receive","(event)",""],["record_entity_expansion","REXML::Document","REXML/Document.html#method-i-record_entity_expansion","()",""],["remove","REXML::Attribute","REXML/Attribute.html#method-i-remove","()","<p>Removes this Attribute from the tree, and returns true if successful\n<p>This method is usually not called …\n"],["remove","REXML::Child","REXML/Child.html#method-i-remove","()","<p>Removes this child from the parent.\n<p>Returns &mdash; self\n\n"],["replace_child","REXML::Parent","REXML/Parent.html#method-i-replace_child","( to_replace, replacement )","<p>Replaces one child with another, making sure the nodelist is correct @param to_replace the child to replace …\n"],["replace_with","REXML::Child","REXML/Child.html#method-i-replace_with","( child )","<p>Replaces this object with another object.  Basically, calls Parent.replace_child\n<p>Returns &mdash; self\n\n"],["reset","REXML::Validation::Choice","REXML/Validation/Choice.html#method-i-reset","()",""],["reset","REXML::Validation::Interleave","REXML/Validation/Interleave.html#method-i-reset","()",""],["reset","REXML::Validation::OneOrMore","REXML/Validation/OneOrMore.html#method-i-reset","()",""],["reset","REXML::Validation::State","REXML/Validation/State.html#method-i-reset","()",""],["reset","REXML::Validation::Validator","REXML/Validation/Validator.html#method-i-reset","()",""],["rewind","REXML::Parsers::LightParser","REXML/Parsers/LightParser.html#method-i-rewind","()",""],["rewind","REXML::Parsers::UltraLightParser","REXML/Parsers/UltraLightParser.html#method-i-rewind","()",""],["root","REXML::Document","REXML/Document.html#method-i-root","()","<p>@return the root Element of the document, or nil if this document has no children.\n"],["root","REXML::Element","REXML/Element.html#method-i-root","()",""],["root","REXML::Light::Node","REXML/Light/Node.html#method-i-root","()",""],["root_node","REXML::Element","REXML/Element.html#method-i-root_node","()","<p>Evaluates to the root node of the document that this element belongs to. If this element doesn&#39;t …\n"],["round","REXML::Functions","REXML/Functions.html#method-c-round","( number )",""],["scan","REXML::IOSource","REXML/IOSource.html#method-i-scan","(pattern, cons=false)",""],["scan","REXML::Source","REXML/Source.html#method-i-scan","(pattern, cons=false)","<p>Scans the source for a given pattern.  Note, that this is not your usual scan() method.  For one thing, …\n"],["send","REXML::Functions","REXML/Functions.html#method-c-send","(name, *args)",""],["single?","REXML::Validation::Event","REXML/Validation/Event.html#method-i-single-3F","()",""],["singleton_method_added","REXML::Functions","REXML/Functions.html#method-c-singleton_method_added","(name)",""],["size","REXML::Attributes","REXML/Attributes.html#method-i-size","()",""],["size","REXML::Elements","REXML/Elements.html#method-i-size","()","<p>Returns the number of <code>Element</code> children of the parent object.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">doc</span> = <span class=\"ruby-constant\">Document</span>.<span class=\"ruby-identifier\">new</span> <span class=\"ruby-string\">&#39;&lt;a&gt;sean&lt;b/&gt;elliott&lt;b/&gt;russell&lt;b/&gt;&lt;/a&gt;&#39;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["size","REXML::Light::Node","REXML/Light/Node.html#method-i-size","()",""],["size","REXML::Parent","REXML/Parent.html#method-i-size","()","<p>@return the number of children of this parent\n"],["sort","REXML::XPathParser","REXML/XPathParser.html#method-i-sort","(array_of_nodes, order)","<p>Reorders an array of nodes so that they are in document order It tries to do this efficiently.\n<p>FIXME: …\n"],["source","REXML::Parsers::SAX2Parser","REXML/Parsers/SAX2Parser.html#method-i-source","()",""],["stand_alone?","REXML::Document","REXML/Document.html#method-i-stand_alone-3F","()","<p>@return the XMLDecl standalone value of this document as a String. If no XMLDecl has been set, returns …\n"],["start_document","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-start_document","()",""],["start_element","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-start_element","(uri, localname, qname, attributes)",""],["start_element?","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-start_element-3F","()","<p>Content: [ String tag_name, Hash attributes ]\n"],["start_prefix_mapping","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-start_prefix_mapping","(prefix, uri)",""],["starts_with","REXML::Functions","REXML/Functions.html#method-c-starts_with","( string, test )","<p>Fixed by Mike Stok\n"],["step","REXML::XPathParser","REXML/XPathParser.html#method-i-step","(path_stack, any_type: :element, order: :forward)",""],["stream=","REXML::Parsers::BaseParser","REXML/Parsers/BaseParser.html#method-i-stream-3D","( source )",""],["strict?","REXML::XPathParser","REXML/XPathParser.html#method-i-strict-3F","()",""],["string","REXML::Functions","REXML/Functions.html#method-c-string","( object=@@context[:node] )","<p>A node-set is converted to a string by returning the string-value of the node in the node-set that is …\n"],["string_length","REXML::Functions","REXML/Functions.html#method-c-string_length","( string )","<p>UNTESTED\n"],["string_value","REXML::Functions","REXML/Functions.html#method-c-string_value","( o )","<p>A node-set is converted to a string by returning the concatenation of the string-value of each of the …\n"],["strip_quotes","REXML::DocType","REXML/DocType.html#method-i-strip_quotes","(quoted_string)","<p>Method contributed by Henrik Martensson\n"],["substring","REXML::Functions","REXML/Functions.html#method-c-substring","( string, start, length=nil )","<p>Take equal portions of Mike Stok and Sean Russell; mix vigorously, and pour into a tall, chilled glass. …\n"],["substring_after","REXML::Functions","REXML/Functions.html#method-c-substring_after","( string, test )","<p>Kouhei fixed this too\n"],["substring_before","REXML::Functions","REXML/Functions.html#method-c-substring_before","( string, test )","<p>Kouhei fixed this\n"],["sum","REXML::Functions","REXML/Functions.html#method-c-sum","( nodes )",""],["system","REXML::DocType","REXML/DocType.html#method-i-system","()","<p>This method retrieves the system identifier identifying the document&#39;s DTD\n<p>Method contributed by  …\n"],["tag_end","REXML::StreamListener","REXML/StreamListener.html#method-i-tag_end","(name)","<p>Called when the end tag is reached.  In the case of &lt;tag/&gt;, tag_end will be called immediately …\n"],["tag_start","REXML::StreamListener","REXML/StreamListener.html#method-i-tag_start","(name, attrs)","<p>Called when a tag is encountered. @p name the tag name @p attrs an array of arrays of attribute/value …\n"],["text","REXML::Element","REXML/Element.html#method-i-text","( path = nil )","<p>A convenience method which returns the String value of the <em>first</em> child text element, if one exists, and …\n"],["text","REXML::Functions","REXML/Functions.html#method-c-text","( )",""],["text","REXML::StreamListener","REXML/StreamListener.html#method-i-text","(text)","<p>Called when text is encountered in the document @p text the text content.\n"],["text=","REXML::Element","REXML/Element.html#method-i-text-3D","( text )","<p>Sets the first Text child of this object.  See text() for a discussion about Text children.\n<p>If a Text …\n"],["text=","REXML::Light::Node","REXML/Light/Node.html#method-i-text-3D","( foo )",""],["text?","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-text-3F","()","<p>Content: [ String raw_text, String unnormalized_text ]\n"],["texts","REXML::Element","REXML/Element.html#method-i-texts","()","<p>Get an array of all Text children. IMMUTABLE\n"],["to_a","REXML::Attributes","REXML/Attributes.html#method-i-to_a","()",""],["to_a","REXML::Elements","REXML/Elements.html#method-i-to_a","( xpath=nil )","<p>Returns an Array of Element children.  An XPath may be supplied to filter the children.  Only Element …\n"],["to_a","REXML::Parent","REXML/Parent.html#method-i-to_a","()",""],["to_s","REXML::Attribute","REXML/Attribute.html#method-i-to_s","()","<p>Returns the attribute value, with entities replaced\n"],["to_s","REXML::CData","REXML/CData.html#method-i-to_s","()","<p>Returns the content of this CData object\n<p><em>Examples</em>\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">c</span> = <span class=\"ruby-constant\">CData</span>.<span class=\"ruby-identifier\">new</span>( <span class=\"ruby-string\">&quot;Some text&quot;</span> )\n<span class=\"ruby-identifier\">c</span>.<span class=\"ruby-identifier\">to_s</span>        <span class=\"ruby-comment\"># -&gt; &quot;Some ...</span>\n</pre>\n"],["to_s","REXML::DTD::EntityDecl","REXML/DTD/EntityDecl.html#method-i-to_s","()",""],["to_s","REXML::DTD::NotationDecl","REXML/DTD/NotationDecl.html#method-i-to_s","()",""],["to_s","REXML::Declaration","REXML/Declaration.html#method-i-to_s","()",""],["to_s","REXML::Entity","REXML/Entity.html#method-i-to_s","()","<p>Returns this entity as a string.  See write().\n"],["to_s","REXML::ExternalEntity","REXML/ExternalEntity.html#method-i-to_s","()",""],["to_s","REXML::Light::Node","REXML/Light/Node.html#method-i-to_s","()",""],["to_s","REXML::Node","REXML/Node.html#method-i-to_s","(indent=nil)","<p>indent &mdash; <strong>DEPRECATED</strong> This parameter is now ignored.  See the formatters in the REXML::Formatters package …\n\n"],["to_s","REXML::NotationDecl","REXML/NotationDecl.html#method-i-to_s","()",""],["to_s","REXML::Output","REXML/Output.html#method-i-to_s","()",""],["to_s","REXML::ParseException","REXML/ParseException.html#method-i-to_s","()",""],["to_s","REXML::Text","REXML/Text.html#method-i-to_s","()","<p>Returns the string value of this text node.  This string is always escaped, meaning that it is a valid …\n"],["to_s","REXML::Validation::Event","REXML/Validation/Event.html#method-i-to_s","()",""],["to_s","REXML::Validation::Ref","REXML/Validation/Ref.html#method-i-to_s","()",""],["to_s","REXML::Validation::State","REXML/Validation/State.html#method-i-to_s","()",""],["to_string","REXML::Attribute","REXML/Attribute.html#method-i-to_string","()","<p>Returns this attribute out as XML source, expanding the name\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">a</span> = <span class=\"ruby-constant\">Attribute</span>.<span class=\"ruby-identifier\">new</span>( <span class=\"ruby-string\">&quot;x&quot;</span>, <span class=\"ruby-string\">&quot;y&quot;</span> )\n<span class=\"ruby-identifier\">a</span>.<span class=\"ruby-identifier\">to_string</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["trace","REXML::XPathParser","REXML/XPathParser.html#method-i-trace","(*args)",""],["translate","REXML::Functions","REXML/Functions.html#method-c-translate","( string, tr1, tr2 )","<p>This is entirely Mike Stok&#39;s beast\n"],["true","REXML::Functions","REXML/Functions.html#method-c-true","( )","<p>UNTESTED\n"],["unnode","REXML::XPathParser","REXML/XPathParser.html#method-i-unnode","(nodeset)",""],["unnormalize","REXML::Parsers::BaseParser","REXML/Parsers/BaseParser.html#method-i-unnormalize","( string, entities=nil, filter=nil )","<p>Unescapes all possible entities\n"],["unnormalize","REXML::Text","REXML/Text.html#method-c-unnormalize","( string, doctype=nil, filter=nil, illegal=nil )","<p>Unescapes all possible entities\n"],["unnormalized","REXML::Entity","REXML/Entity.html#method-i-unnormalized","()","<p>Evaluates to the unnormalized value of this entity; that is, replacing all entities – both %ent; and …\n"],["unshift","REXML::Parent","REXML/Parent.html#method-i-unshift","( object )",""],["unshift","REXML::Parsers::BaseParser","REXML/Parsers/BaseParser.html#method-i-unshift","(token)","<p>Push an event back on the head of the stream.  This method has (theoretically) infinite depth.\n"],["unshift","REXML::Parsers::PullParser","REXML/Parsers/PullParser.html#method-i-unshift","(token)",""],["validate","REXML::Validation::Validator","REXML/Validation/Validator.html#method-i-validate","( event )",""],["value","REXML::Attribute","REXML/Attribute.html#method-i-value","()","<p>Returns the UNNORMALIZED value of this attribute.  That is, entities have been expanded to their values …\n"],["value","REXML::CData","REXML/CData.html#method-i-value","()",""],["value","REXML::Entity","REXML/Entity.html#method-i-value","()","<p>Returns the value of this entity.  At the moment, only internal entities are processed.  If the value …\n"],["value","REXML::Text","REXML/Text.html#method-i-value","()","<p>Returns the string value of this text.  This is the text without entities, as it might be used programmatically, …\n"],["value=","REXML::Text","REXML/Text.html#method-i-value-3D","( val )","<p>Sets the contents of this text node.  This expects the text to be unnormalized.  It returns self.\n\n<pre>e = ...</pre>\n"],["value_type","REXML::XPathParser","REXML/XPathParser.html#method-i-value_type","(value)",""],["variables","REXML::Functions","REXML/Functions.html#method-c-variables","()",""],["variables=","REXML::Functions","REXML/Functions.html#method-c-variables-3D","(x)",""],["variables=","REXML::XPathParser","REXML/XPathParser.html#method-i-variables-3D","( vars={} )",""],["version","REXML::Document","REXML/Document.html#method-i-version","()","<p>@return the XMLDecl version of this document as a String. If no XMLDecl has been set, returns the default …\n"],["whitespace","REXML::Element","REXML/Element.html#method-i-whitespace","()","<p>Evaluates to <code>true</code> if whitespace is respected for this element.  This is the case if:\n<p>Neither :<code>respect_whitespace</code> …\n"],["wrap","REXML::Formatters::Pretty","REXML/Formatters/Pretty.html#method-i-wrap","(string, width)",""],["wrap","REXML::Text","REXML/Text.html#method-i-wrap","(string, width, addnewline=false)",""],["write","REXML::AttlistDecl","REXML/AttlistDecl.html#method-i-write","(out, indent=-1)","<p>Write out exactly what we got in.\n"],["write","REXML::Attribute","REXML/Attribute.html#method-i-write","( output, indent=-1 )","<p>Writes this attribute (EG, puts &#39;key=“value”&#39; to the output)\n"],["write","REXML::CData","REXML/CData.html#method-i-write","( output=$stdout, indent=-1, transitive=false, ie_hack=false )","<p>DEPRECATED\n<p>See the rexml/formatters package\n<p>Generates XML output of this object\n"],["write","REXML::Comment","REXML/Comment.html#method-i-write","( output, indent=-1, transitive=false, ie_hack=false )","<p>DEPRECATED\n<p>See REXML::Formatters\n<p>output &mdash; Where to write the string\n"],["write","REXML::DTD::EntityDecl","REXML/DTD/EntityDecl.html#method-i-write","( output, indent )",""],["write","REXML::DTD::NotationDecl","REXML/DTD/NotationDecl.html#method-i-write","( output, indent )",""],["write","REXML::Declaration","REXML/Declaration.html#method-i-write","( output, indent )","<p>DEPRECATED\n<p>See REXML::Formatters\n"],["write","REXML::DocType","REXML/DocType.html#method-i-write","( output, indent=0, transitive=false, ie_hack=false )","<p>output &mdash; Where to write the string\n<p>indent &mdash; An integer.  If -1, no indentation will be used; otherwise, the …\n"],["write","REXML::Document","REXML/Document.html#method-i-write","(*arguments)","<p>Write the XML tree out, optionally with indent.  This writes out the entire XML document, including  …\n"],["write","REXML::Element","REXML/Element.html#method-i-write","(output=$stdout, indent=-1, transitive=false, ie_hack=false)","<p>DEPRECATED\n<p>See REXML::Formatters\n<p>Writes out this element, and recursively, all children.\n"],["write","REXML::Entity","REXML/Entity.html#method-i-write","(out, indent=-1)","<p>Write out a fully formed, correct entity definition (assuming the Entity object itself is valid.)\n<p>out … &mdash; "],["write","REXML::ExternalEntity","REXML/ExternalEntity.html#method-i-write","( output, indent )",""],["write","REXML::Formatters::Default","REXML/Formatters/Default.html#method-i-write","( node, output )","<p>Writes the node to some output.\n<p>node &mdash; The node to write\n<p>output &mdash; A class implementing <code>&amp;lt;&amp;lt;</code>.   …\n"],["write","REXML::Instruction","REXML/Instruction.html#method-i-write","(writer, indent=-1, transitive=false, ie_hack=false)","<p>DEPRECATED\n<p>See the rexml/formatters package\n"],["write","REXML::NotationDecl","REXML/NotationDecl.html#method-i-write","( output, indent=-1 )",""],["write","REXML::Text","REXML/Text.html#method-i-write","( writer, indent=-1, transitive=false, ie_hack=false )","<p>DEPRECATED\n<p>See REXML::Formatters\n"],["write","REXML::XMLDecl","REXML/XMLDecl.html#method-i-write","(writer, indent=-1, transitive=false, ie_hack=false)","<p>indent &mdash; Ignored.  There must be no whitespace before an XML declaration\n<p>transitive &mdash; Ignored\n<p>ie_hack &mdash; Ignored …\n"],["write_cdata","REXML::Formatters::Default","REXML/Formatters/Default.html#method-i-write_cdata","( node, output )",""],["write_cdata","REXML::Formatters::Pretty","REXML/Formatters/Pretty.html#method-i-write_cdata","( node, output)",""],["write_comment","REXML::Formatters::Default","REXML/Formatters/Default.html#method-i-write_comment","( node, output )",""],["write_comment","REXML::Formatters::Pretty","REXML/Formatters/Pretty.html#method-i-write_comment","( node, output)",""],["write_document","REXML::Formatters::Default","REXML/Formatters/Default.html#method-i-write_document","( node, output )",""],["write_document","REXML::Formatters::Pretty","REXML/Formatters/Pretty.html#method-i-write_document","( node, output )",""],["write_element","REXML::Formatters::Default","REXML/Formatters/Default.html#method-i-write_element","( node, output )",""],["write_element","REXML::Formatters::Pretty","REXML/Formatters/Pretty.html#method-i-write_element","(node, output)",""],["write_element","REXML::Formatters::Transitive","REXML/Formatters/Transitive.html#method-i-write_element","( node, output )",""],["write_instruction","REXML::Formatters::Default","REXML/Formatters/Default.html#method-i-write_instruction","( node, output )",""],["write_text","REXML::Formatters::Default","REXML/Formatters/Default.html#method-i-write_text","( node, output )",""],["write_text","REXML::Formatters::Pretty","REXML/Formatters/Pretty.html#method-i-write_text","( node, output )",""],["write_text","REXML::Formatters::Transitive","REXML/Formatters/Transitive.html#method-i-write_text","( node, output )",""],["write_with_substitution","REXML::Text","REXML/Text.html#method-i-write_with_substitution","(out, input)","<p>Writes out text, substituting special characters beforehand. <code>out</code> A String, IO, or any other object supporting …\n"],["xml_decl","REXML::Document","REXML/Document.html#method-i-xml_decl","()","<p>@return the XMLDecl of this document; if no XMLDecl has been set, the default declaration is returned. …\n"],["xmldecl","REXML::SAX2Listener","REXML/SAX2Listener.html#method-i-xmldecl","(version, encoding, standalone)","<p>Called when an XML PI is encountered in the document. EG: &lt;?xml version=“1.0” encoding=“utf”?&gt; …\n"],["xmldecl","REXML::StreamListener","REXML/StreamListener.html#method-i-xmldecl","(version, encoding, standalone)","<p>Called when an XML PI is encountered in the document. EG: &lt;?xml version=“1.0” encoding=“utf”?&gt; …\n"],["xmldecl","REXML::XMLDecl","REXML/XMLDecl.html#method-i-xmldecl","(version, encoding, standalone)",""],["xmldecl?","REXML::Parsers::PullEvent","REXML/Parsers/PullEvent.html#method-i-xmldecl-3F","()","<p>Content: [ String version, String encoding, String standalone ]\n"],["xpath","REXML::Attribute","REXML/Attribute.html#method-i-xpath","()",""],["xpath","REXML::Element","REXML/Element.html#method-i-xpath","()",""],["xpath","REXML::Text","REXML/Text.html#method-i-xpath","()","<p>FIXME This probably won&#39;t work properly\n"]]}}