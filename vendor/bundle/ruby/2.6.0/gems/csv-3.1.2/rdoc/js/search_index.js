var search_data = {"index":{"searchIndex":["array","csv","deletesuffix","fieldsconverter","malformedcsverror","matchp","parser","inputsscanner","invalidencoding","scanner","unoptimizedstringio","row","row","table","writer","object","string","<<()","<<()","<<()","<<()","==()","==()","csv()","[]()","[]()","[]=()","[]=()","add_converter()","add_row()","add_unconverted_fields()","adjust_headers()","binmode?()","build_fields_converter()","build_header_fields_converter()","build_parser_fields_converter()","build_scanner()","build_writer_fields_converter()","by_col()","by_col!()","by_col_or_row()","by_col_or_row!()","by_row()","by_row!()","col_sep()","column_separator()","convert()","convert()","convert_fields()","converters()","delete()","delete()","delete_if()","delete_if()","delete_suffix()","detect_row_separator()","determine_encoding()","dig()","dig()","each()","each()","each()","each()","each_line()","each_line()","each_line()","each_pair()","emit_row()","empty?()","eof()","eof?()","eof?()","eos?()","fetch()","field()","field?()","field_row?()","field_size_limit()","field_size_limit()","fields()","filter()","flock()","force_quotes?()","foreach()","generate()","generate_line()","gets()","gets()","has_key?()","header?()","header_convert()","header_converters()","header_fields_converter()","header_row?()","header_row?()","header_row?()","headers()","headers()","headers()","headers()","ignore_broken_line()","include?()","index()","initialize_copy()","inspect()","inspect()","inspect()","instance()","ioctl()","keep_back()","keep_back()","keep_drop()","keep_drop()","keep_end()","keep_end()","keep_start()","keep_start()","key?()","last_line()","liberal_parsing?()","liberal_parsing?()","line()","line()","lineno()","lineno()","match?()","may_quoted?()","member?()","need_convert?()","need_static_convert?()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","normalize_converters()","open()","parse()","parse()","parse_column_end()","parse_column_value()","parse_headers()","parse_line()","parse_no_quote()","parse_quotable_loose()","parse_quotable_robust()","parse_quoted_column_value()","parse_row_end()","parse_unquoted_column_value()","parser()","parser_enumerator()","parser_fields_converter()","parser_options()","path()","prepare()","prepare()","prepare_backslash()","prepare_format()","prepare_header()","prepare_header()","prepare_line()","prepare_output()","prepare_parser()","prepare_quote_character()","prepare_quoted()","prepare_separators()","prepare_skip_lines()","prepare_strip()","prepare_unquoted()","prepare_variable()","push()","push()","puts()","quote()","quote_char()","quote_character()","quote_field()","raw_encoding()","read()","read()","read_chunk()","readline()","readlines()","readlines()","resolve_row_separator()","rest()","return_headers?()","return_headers?()","rewind()","rewind()","row_sep()","row_separator()","scan()","scan_all()","shift()","skip_blanks?()","skip_blanks?()","skip_line?()","skip_lines()","skip_lines()","skip_needless_lines()","start_row()","stat()","strip_value()","table()","to_a()","to_csv()","to_csv()","to_h()","to_hash()","to_i()","to_io()","to_s()","to_s()","unconverted_fields?()","unconverted_fields?()","use_headers?()","values_at()","values_at()","write_headers?()","writer()","writer_fields_converter()","writer_options()"],"longSearchIndex":["array","csv","csv::deletesuffix","csv::fieldsconverter","csv::malformedcsverror","csv::matchp","csv::parser","csv::parser::inputsscanner","csv::parser::invalidencoding","csv::parser::scanner","csv::parser::unoptimizedstringio","csv::parser::row","csv::row","csv::table","csv::writer","object","string","csv#<<()","csv::row#<<()","csv::table#<<()","csv::writer#<<()","csv::row#==()","csv::table#==()","object#csv()","csv::row#[]()","csv::table#[]()","csv::row#[]=()","csv::table#[]=()","csv::fieldsconverter#add_converter()","csv#add_row()","csv::parser#add_unconverted_fields()","csv::parser#adjust_headers()","csv#binmode?()","csv#build_fields_converter()","csv#build_header_fields_converter()","csv#build_parser_fields_converter()","csv::parser#build_scanner()","csv#build_writer_fields_converter()","csv::table#by_col()","csv::table#by_col!()","csv::table#by_col_or_row()","csv::table#by_col_or_row!()","csv::table#by_row()","csv::table#by_row!()","csv#col_sep()","csv::parser#column_separator()","csv#convert()","csv::fieldsconverter#convert()","csv#convert_fields()","csv#converters()","csv::row#delete()","csv::table#delete()","csv::row#delete_if()","csv::table#delete_if()","csv::deletesuffix#delete_suffix()","csv::parser#detect_row_separator()","csv#determine_encoding()","csv::row#dig()","csv::table#dig()","csv#each()","csv::fieldsconverter#each()","csv::row#each()","csv::table#each()","csv::parser::inputsscanner#each_line()","csv::parser::scanner#each_line()","csv::parser::unoptimizedstringio#each_line()","csv::row#each_pair()","csv::parser#emit_row()","csv::fieldsconverter#empty?()","csv#eof()","csv#eof?()","csv::parser::unoptimizedstringio#eof?()","csv::parser::inputsscanner#eos?()","csv::row#fetch()","csv::row#field()","csv::row#field?()","csv::row#field_row?()","csv#field_size_limit()","csv::parser#field_size_limit()","csv::row#fields()","csv::filter()","csv#flock()","csv#force_quotes?()","csv::foreach()","csv::generate()","csv::generate_line()","csv#gets()","csv::parser::unoptimizedstringio#gets()","csv::row#has_key?()","csv::row#header?()","csv#header_convert()","csv#header_converters()","csv#header_fields_converter()","csv#header_row?()","csv::parser#header_row?()","csv::row#header_row?()","csv#headers()","csv::parser#headers()","csv::row#headers()","csv::table#headers()","csv::parser#ignore_broken_line()","csv::row#include?()","csv::row#index()","csv::row#initialize_copy()","csv#inspect()","csv::row#inspect()","csv::table#inspect()","csv::instance()","csv#ioctl()","csv::parser::inputsscanner#keep_back()","csv::parser::scanner#keep_back()","csv::parser::inputsscanner#keep_drop()","csv::parser::scanner#keep_drop()","csv::parser::inputsscanner#keep_end()","csv::parser::scanner#keep_end()","csv::parser::inputsscanner#keep_start()","csv::parser::scanner#keep_start()","csv::row#key?()","csv::parser#last_line()","csv#liberal_parsing?()","csv::parser#liberal_parsing?()","csv#line()","csv::parser#line()","csv#lineno()","csv::parser#lineno()","csv::matchp#match?()","csv::parser#may_quoted?()","csv::row#member?()","csv::fieldsconverter#need_convert?()","csv::fieldsconverter#need_static_convert?()","csv::new()","csv::fieldsconverter::new()","csv::malformedcsverror::new()","csv::parser::new()","csv::parser::inputsscanner::new()","csv::parser::scanner::new()","csv::parser::unoptimizedstringio::new()","csv::row::new()","csv::table::new()","csv::writer::new()","csv#normalize_converters()","csv::open()","csv::parse()","csv::parser#parse()","csv::parser#parse_column_end()","csv::parser#parse_column_value()","csv::parser#parse_headers()","csv::parse_line()","csv::parser#parse_no_quote()","csv::parser#parse_quotable_loose()","csv::parser#parse_quotable_robust()","csv::parser#parse_quoted_column_value()","csv::parser#parse_row_end()","csv::parser#parse_unquoted_column_value()","csv#parser()","csv#parser_enumerator()","csv#parser_fields_converter()","csv#parser_options()","csv#path()","csv::parser#prepare()","csv::writer#prepare()","csv::parser#prepare_backslash()","csv::writer#prepare_format()","csv::parser#prepare_header()","csv::writer#prepare_header()","csv::parser#prepare_line()","csv::writer#prepare_output()","csv::parser#prepare_parser()","csv::parser#prepare_quote_character()","csv::parser#prepare_quoted()","csv::parser#prepare_separators()","csv::parser#prepare_skip_lines()","csv::parser#prepare_strip()","csv::parser#prepare_unquoted()","csv::parser#prepare_variable()","csv::row#push()","csv::table#push()","csv#puts()","csv::writer#quote()","csv#quote_char()","csv::parser#quote_character()","csv::writer#quote_field()","csv#raw_encoding()","csv#read()","csv::read()","csv::parser::inputsscanner#read_chunk()","csv#readline()","csv#readlines()","csv::readlines()","csv::parser#resolve_row_separator()","csv::parser::inputsscanner#rest()","csv#return_headers?()","csv::parser#return_headers?()","csv#rewind()","csv::writer#rewind()","csv#row_sep()","csv::parser#row_separator()","csv::parser::inputsscanner#scan()","csv::parser::inputsscanner#scan_all()","csv#shift()","csv#skip_blanks?()","csv::parser#skip_blanks?()","csv::parser#skip_line?()","csv#skip_lines()","csv::parser#skip_lines()","csv::parser#skip_needless_lines()","csv::parser#start_row()","csv#stat()","csv::parser#strip_value()","csv::table()","csv::table#to_a()","csv::row#to_csv()","csv::table#to_csv()","csv::row#to_h()","csv::row#to_hash()","csv#to_i()","csv#to_io()","csv::row#to_s()","csv::table#to_s()","csv#unconverted_fields?()","csv::parser#unconverted_fields?()","csv::parser#use_headers?()","csv::row#values_at()","csv::table#values_at()","csv#write_headers?()","csv#writer()","csv#writer_fields_converter()","csv#writer_options()"],"info":[["Array","","Array.html","",""],["CSV","","CSV.html","","<p>This class provides a complete interface to CSV files and data. It offers tools to enable you to read …\n"],["CSV::DeleteSuffix","","CSV/DeleteSuffix.html","",""],["CSV::FieldsConverter","","CSV/FieldsConverter.html","","<p>Note: Don&#39;t use this class directly. This is an internal class.\n"],["CSV::MalformedCSVError","","CSV/MalformedCSVError.html","","<p>The error thrown when the parser encounters illegal CSV formatting.\n"],["CSV::MatchP","","CSV/MatchP.html","",""],["CSV::Parser","","CSV/Parser.html","","<p>Note: Don&#39;t use this class directly. This is an internal class.\n"],["CSV::Parser::InputsScanner","","CSV/Parser/InputsScanner.html","","<p>CSV::InputsScanner receives IO inputs, encoding and the chunk_size. It also controls the life cycle of …\n"],["CSV::Parser::InvalidEncoding","","CSV/Parser/InvalidEncoding.html","","<p>Raised when encoding is invalid.\n"],["CSV::Parser::Scanner","","CSV/Parser/Scanner.html","","<p>CSV::Scanner receives a CSV output, scans it and return the content. It also controls the life cycle …\n"],["CSV::Parser::UnoptimizedStringIO","","CSV/Parser/UnoptimizedStringIO.html","",""],["CSV::Parser::row","","CSV/Parser/row.html","",""],["CSV::Row","","CSV/Row.html","","<p>A CSV::Row is part Array and part Hash. It retains an order for the fields and allows duplicates just …\n"],["CSV::Table","","CSV/Table.html","","<p>A CSV::Table is a two-dimensional data structure for representing CSV documents. Tables allow you to …\n"],["CSV::Writer","","CSV/Writer.html","","<p>Note: Don&#39;t use this class directly. This is an internal class.\n"],["Object","","Object.html","",""],["String","","String.html","",""],["<<","CSV","CSV.html#method-i-3C-3C","(row)","<p>The primary write method for wrapped Strings and IOs, <code>row</code> (an Array or CSV::Row) is converted to CSV …\n"],["<<","CSV::Row","CSV/Row.html#method-i-3C-3C","(arg)","<p>If a two-element Array is provided, it is assumed to be a header and field and the pair is appended. …\n"],["<<","CSV::Table","CSV/Table.html#method-i-3C-3C","(row_or_array)","<p>Adds a new row to the bottom end of this table. You can provide an Array, which will be converted to …\n"],["<<","CSV::Writer","CSV/Writer.html#method-i-3C-3C","(row)","<p>Adds a new row\n"],["==","CSV::Row","CSV/Row.html#method-i-3D-3D","(other)","<p>Returns <code>true</code> if this row contains the same headers and fields in the same order as <code>other</code>.\n"],["==","CSV::Table","CSV/Table.html#method-i-3D-3D","(other)","<p>Returns <code>true</code> if all rows of this table ==() <code>other</code>&#39;s rows.\n"],["CSV","Object","Object.html#method-i-CSV","(*args, &block)","<p>Passes <code>args</code> to CSV::instance.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">CSV</span>(<span class=\"ruby-string\">&quot;CSV,data&quot;</span>).<span class=\"ruby-identifier\">read</span>\n  <span class=\"ruby-comment\">#=&gt; [[&quot;CSV&quot;, &quot;data&quot;]]</span>\n</pre>\n<p>If a block is given, the instance …\n"],["[]","CSV::Row","CSV/Row.html#method-i-5B-5D","(header_or_index, minimum_index = 0)",""],["[]","CSV::Table","CSV/Table.html#method-i-5B-5D","(index_or_header)","<p>In the default mixed mode, this method returns rows for index access and columns for header access.  …\n"],["[]=","CSV::Row","CSV/Row.html#method-i-5B-5D-3D","(*args)","<p>Looks up the field by the semantics described in CSV::Row.field() and assigns the <code>value</code>.\n<p>Assigning past …\n"],["[]=","CSV::Table","CSV/Table.html#method-i-5B-5D-3D","(index_or_header, value)","<p>In the default mixed mode, this method assigns rows for index access and columns for header access.  …\n"],["add_converter","CSV::FieldsConverter","CSV/FieldsConverter.html#method-i-add_converter","(name=nil, &converter)",""],["add_row","CSV","CSV.html#method-i-add_row","(row)",""],["add_unconverted_fields","CSV::Parser","CSV/Parser.html#method-i-add_unconverted_fields","(row, fields)","<p>This method injects an instance variable <code>unconverted_fields</code> into <code>row</code> and an accessor method for <code>row</code> called …\n"],["adjust_headers","CSV::Parser","CSV/Parser.html#method-i-adjust_headers","(headers)",""],["binmode?","CSV","CSV.html#method-i-binmode-3F","()",""],["build_fields_converter","CSV","CSV.html#method-i-build_fields_converter","(initial_converters, options)",""],["build_header_fields_converter","CSV","CSV.html#method-i-build_header_fields_converter","()",""],["build_parser_fields_converter","CSV","CSV.html#method-i-build_parser_fields_converter","()",""],["build_scanner","CSV::Parser","CSV/Parser.html#method-i-build_scanner","()",""],["build_writer_fields_converter","CSV","CSV.html#method-i-build_writer_fields_converter","()",""],["by_col","CSV::Table","CSV/Table.html#method-i-by_col","()","<p>Returns a duplicate table object, in column mode. This is handy for chaining in a single call without …\n"],["by_col!","CSV::Table","CSV/Table.html#method-i-by_col-21","()","<p>Switches the mode of this table to column mode. All calls to indexing and iteration methods will work …\n"],["by_col_or_row","CSV::Table","CSV/Table.html#method-i-by_col_or_row","()","<p>Returns a duplicate table object, in mixed mode. This is handy for chaining in a single call without …\n"],["by_col_or_row!","CSV::Table","CSV/Table.html#method-i-by_col_or_row-21","()","<p>Switches the mode of this table to mixed mode. All calls to indexing and iteration methods will use the …\n"],["by_row","CSV::Table","CSV/Table.html#method-i-by_row","()","<p>Returns a duplicate table object, in row mode.  This is handy for chaining in a single call without changing …\n"],["by_row!","CSV::Table","CSV/Table.html#method-i-by_row-21","()","<p>Switches the mode of this table to row mode. All calls to indexing and iteration methods will work with …\n"],["col_sep","CSV","CSV.html#method-i-col_sep","()","<p>The encoded <code>:col_sep</code> used in parsing and writing. See CSV::new for details.\n"],["column_separator","CSV::Parser","CSV/Parser.html#method-i-column_separator","()",""],["convert","CSV","CSV.html#method-i-convert","(name = nil, &converter)","<p>You can use this method to install a CSV::Converters built-in, or provide a block that handles a custom …\n"],["convert","CSV::FieldsConverter","CSV/FieldsConverter.html#method-i-convert","(fields, headers, lineno)",""],["convert_fields","CSV","CSV.html#method-i-convert_fields","(fields, headers = false)","<p>Processes <code>fields</code> with <code>@converters</code>, or <code>@header_converters</code> if <code>headers</code> is passed as <code>true</code>, returning the …\n"],["converters","CSV","CSV.html#method-i-converters","()","<p>Returns the current list of converters in effect. See CSV::new for details. Built-in converters will …\n"],["delete","CSV::Row","CSV/Row.html#method-i-delete","(header_or_index, minimum_index = 0)","<p>Removes a pair from the row by <code>header</code> or <code>index</code>. The pair is located as described in CSV::Row.field() …\n"],["delete","CSV::Table","CSV/Table.html#method-i-delete","(*indexes_or_headers)","<p>Removes and returns the indicated columns or rows. In the default mixed mode indices refer to rows and …\n"],["delete_if","CSV::Row","CSV/Row.html#method-i-delete_if","(&block)","<p>The provided <code>block</code> is passed a header and field for each pair in the row and expected to return <code>true</code> …\n"],["delete_if","CSV::Table","CSV/Table.html#method-i-delete_if","(&block)","<p>Removes any column or row for which the block returns <code>true</code>. In the default mixed mode or row mode, iteration …\n"],["delete_suffix","CSV::DeleteSuffix","CSV/DeleteSuffix.html#method-i-delete_suffix","(suffix)",""],["detect_row_separator","CSV::Parser","CSV/Parser.html#method-i-detect_row_separator","(sample, cr, lf)",""],["determine_encoding","CSV","CSV.html#method-i-determine_encoding","(encoding, internal_encoding)",""],["dig","CSV::Row","CSV/Row.html#method-i-dig","(index_or_header, *indexes)","<p>Extracts the nested value specified by the sequence of <code>index</code> or <code>header</code> objects by calling dig at each …\n"],["dig","CSV::Table","CSV/Table.html#method-i-dig","(index_or_header, *index_or_headers)","<p>Extracts the nested value specified by the sequence of <code>index</code> or <code>header</code> objects by calling dig at each …\n"],["each","CSV","CSV.html#method-i-each","(&block)","<p>Yields each row of the data source in turn.\n<p>Support for Enumerable.\n<p>The data source must be open for reading. …\n"],["each","CSV::FieldsConverter","CSV/FieldsConverter.html#method-i-each","(&block)",""],["each","CSV::Row","CSV/Row.html#method-i-each","(&block)","<p>Yields each pair of the row as header and field tuples (much like iterating over a Hash). This method …\n"],["each","CSV::Table","CSV/Table.html#method-i-each","(&block)","<p>In the default mixed mode or row mode, iteration is the standard row major walking of rows. In column …\n"],["each_line","CSV::Parser::InputsScanner","CSV/Parser/InputsScanner.html#method-i-each_line","(row_separator)",""],["each_line","CSV::Parser::Scanner","CSV/Parser/Scanner.html#method-i-each_line","(row_separator)",""],["each_line","CSV::Parser::UnoptimizedStringIO","CSV/Parser/UnoptimizedStringIO.html#method-i-each_line","(*args, &block)",""],["each_pair","CSV::Row","CSV/Row.html#method-i-each_pair","(&block)",""],["emit_row","CSV::Parser","CSV/Parser.html#method-i-emit_row","(row, &block)",""],["empty?","CSV::FieldsConverter","CSV/FieldsConverter.html#method-i-empty-3F","()",""],["eof","CSV","CSV.html#method-i-eof","()",""],["eof?","CSV","CSV.html#method-i-eof-3F","()",""],["eof?","CSV::Parser::UnoptimizedStringIO","CSV/Parser/UnoptimizedStringIO.html#method-i-eof-3F","()",""],["eos?","CSV::Parser::InputsScanner","CSV/Parser/InputsScanner.html#method-i-eos-3F","()",""],["fetch","CSV::Row","CSV/Row.html#method-i-fetch","(header, *varargs)","<p>This method will fetch the field value by <code>header</code>. It has the same behavior as Hash#fetch: if there is …\n"],["field","CSV::Row","CSV/Row.html#method-i-field","(header_or_index, minimum_index = 0)","<p>This method will return the field value by <code>header</code> or <code>index</code>. If a field is not found, <code>nil</code> is returned. …\n"],["field?","CSV::Row","CSV/Row.html#method-i-field-3F","(data)","<p>Returns <code>true</code> if <code>data</code> matches a field in this row, and <code>false</code> otherwise.\n"],["field_row?","CSV::Row","CSV/Row.html#method-i-field_row-3F","()","<p>Returns <code>true</code> if this is a field row.\n"],["field_size_limit","CSV","CSV.html#method-i-field_size_limit","()","<p>The limit for field size, if any. See CSV::new for details.\n"],["field_size_limit","CSV::Parser","CSV/Parser.html#method-i-field_size_limit","()",""],["fields","CSV::Row","CSV/Row.html#method-i-fields","(*headers_and_or_indices)","<p>This method accepts any number of arguments which can be headers, indices, Ranges of either, or two-element …\n"],["filter","CSV","CSV.html#method-c-filter","(input=nil, output=nil, **options)","<p>This method is a convenience for building Unix-like filters for CSV data. Each row is yielded to the …\n"],["flock","CSV","CSV.html#method-i-flock","(*args)",""],["force_quotes?","CSV","CSV.html#method-i-force_quotes-3F","()","<p>Returns <code>true</code> if all output fields are quoted. See CSV::new for details.\n"],["foreach","CSV","CSV.html#method-c-foreach","(path, mode=\"r\", **options, &block)","<p>This method is intended as the primary interface for reading CSV files. You pass a <code>path</code> and any <code>options</code> …\n"],["generate","CSV","CSV.html#method-c-generate","(str=nil, **options)","<p>This method wraps a String you provide, or an empty default String, in a CSV object which is passed to …\n"],["generate_line","CSV","CSV.html#method-c-generate_line","(row, **options)","<p>This method is a shortcut for converting a single row (Array) into a CSV String.\n<p>The <code>options</code> parameter …\n"],["gets","CSV","CSV.html#method-i-gets","()",""],["gets","CSV::Parser::UnoptimizedStringIO","CSV/Parser/UnoptimizedStringIO.html#method-i-gets","(*args)",""],["has_key?","CSV::Row","CSV/Row.html#method-i-has_key-3F","(header)","<p>Returns <code>true</code> if there is a field with the given <code>header</code>.\n"],["header?","CSV::Row","CSV/Row.html#method-i-header-3F","(header)",""],["header_convert","CSV","CSV.html#method-i-header_convert","(name = nil, &converter)","<p>Identical to CSV#convert(), but for header rows.\n<p>Note that this method must be called before header rows …\n"],["header_converters","CSV","CSV.html#method-i-header_converters","()","<p>Returns the current list of converters in effect for headers. See CSV::new for details. Built-in converters …\n"],["header_fields_converter","CSV","CSV.html#method-i-header_fields_converter","()",""],["header_row?","CSV","CSV.html#method-i-header_row-3F","()","<p>Returns <code>true</code> if the next row read will be a header row.\n"],["header_row?","CSV::Parser","CSV/Parser.html#method-i-header_row-3F","()",""],["header_row?","CSV::Row","CSV/Row.html#method-i-header_row-3F","()","<p>Returns <code>true</code> if this is a header row.\n"],["headers","CSV","CSV.html#method-i-headers","()","<p>Returns <code>nil</code> if headers will not be used, <code>true</code> if they will but have not yet been read, or the actual …\n"],["headers","CSV::Parser","CSV/Parser.html#method-i-headers","()",""],["headers","CSV::Row","CSV/Row.html#method-i-headers","()","<p>Returns the headers of this row.\n"],["headers","CSV::Table","CSV/Table.html#method-i-headers","()","<p>Returns the headers for the first row of this table (assumed to match all other rows). The headers Array …\n"],["ignore_broken_line","CSV::Parser","CSV/Parser.html#method-i-ignore_broken_line","()",""],["include?","CSV::Row","CSV/Row.html#method-i-include-3F","(header)",""],["index","CSV::Row","CSV/Row.html#method-i-index","(header, minimum_index = 0)","<p>This method will return the index of a field with the provided <code>header</code>. The <code>offset</code> can be used to locate …\n"],["initialize_copy","CSV::Row","CSV/Row.html#method-i-initialize_copy","(other)",""],["inspect","CSV","CSV.html#method-i-inspect","()","<p>Returns a simplified description of the key CSV attributes in an ASCII compatible String.\n"],["inspect","CSV::Row","CSV/Row.html#method-i-inspect","()","<p>A summary of fields, by header, in an ASCII compatible String.\n"],["inspect","CSV::Table","CSV/Table.html#method-i-inspect","()","<p>Shows the mode and size of this table in a US-ASCII String.\n"],["instance","CSV","CSV.html#method-c-instance","(data = $stdout, **options)","<p>This method will return a CSV instance, just like CSV::new(), but the instance will be cached and returned …\n"],["ioctl","CSV","CSV.html#method-i-ioctl","(*args)",""],["keep_back","CSV::Parser::InputsScanner","CSV/Parser/InputsScanner.html#method-i-keep_back","()",""],["keep_back","CSV::Parser::Scanner","CSV/Parser/Scanner.html#method-i-keep_back","()",""],["keep_drop","CSV::Parser::InputsScanner","CSV/Parser/InputsScanner.html#method-i-keep_drop","()",""],["keep_drop","CSV::Parser::Scanner","CSV/Parser/Scanner.html#method-i-keep_drop","()",""],["keep_end","CSV::Parser::InputsScanner","CSV/Parser/InputsScanner.html#method-i-keep_end","()",""],["keep_end","CSV::Parser::Scanner","CSV/Parser/Scanner.html#method-i-keep_end","()",""],["keep_start","CSV::Parser::InputsScanner","CSV/Parser/InputsScanner.html#method-i-keep_start","()",""],["keep_start","CSV::Parser::Scanner","CSV/Parser/Scanner.html#method-i-keep_start","()",""],["key?","CSV::Row","CSV/Row.html#method-i-key-3F","(header)",""],["last_line","CSV::Parser","CSV/Parser.html#method-i-last_line","()",""],["liberal_parsing?","CSV","CSV.html#method-i-liberal_parsing-3F","()","<p>Returns <code>true</code> if illegal input is handled. See CSV::new for details.\n"],["liberal_parsing?","CSV::Parser","CSV/Parser.html#method-i-liberal_parsing-3F","()",""],["line","CSV","CSV.html#method-i-line","()","<p>The last row read from this file.\n"],["line","CSV::Parser","CSV/Parser.html#method-i-line","()",""],["lineno","CSV","CSV.html#method-i-lineno","()","<p>The line number of the last row read from this file. Fields with nested line-end characters will not …\n"],["lineno","CSV::Parser","CSV/Parser.html#method-i-lineno","()",""],["match?","CSV::MatchP","CSV/MatchP.html#method-i-match-3F","(pattern)",""],["may_quoted?","CSV::Parser","CSV/Parser.html#method-i-may_quoted-3F","()",""],["member?","CSV::Row","CSV/Row.html#method-i-member-3F","(header)",""],["need_convert?","CSV::FieldsConverter","CSV/FieldsConverter.html#method-i-need_convert-3F","()",""],["need_static_convert?","CSV::FieldsConverter","CSV/FieldsConverter.html#method-i-need_static_convert-3F","()",""],["new","CSV","CSV.html#method-c-new","(data, col_sep: \",\", row_sep: :auto, quote_char: '\"', field_size_limit: nil, converters: nil, unconverted_fields: nil, headers: false, return_headers: false, write_headers: nil, header_converters: nil, skip_blanks: false, force_quotes: false, skip_lines: nil, liberal_parsing: false, internal_encoding: nil, external_encoding: nil, encoding: nil, nil_value: nil, empty_value: \"\", quote_empty: true, write_converters: nil, write_nil_value: nil, write_empty_value: \"\", strip: false)","<p>This constructor will wrap either a String or IO object passed in <code>data</code> for reading and/or writing. In …\n"],["new","CSV::FieldsConverter","CSV/FieldsConverter.html#method-c-new","(options={})","<p>A CSV::FieldsConverter is a data structure for storing the fields converter properties to be passed as …\n"],["new","CSV::MalformedCSVError","CSV/MalformedCSVError.html#method-c-new","(message, line_number)",""],["new","CSV::Parser","CSV/Parser.html#method-c-new","(input, options)",""],["new","CSV::Parser::InputsScanner","CSV/Parser/InputsScanner.html#method-c-new","(inputs, encoding, chunk_size: 8192)",""],["new","CSV::Parser::Scanner","CSV/Parser/Scanner.html#method-c-new","(*args)",""],["new","CSV::Parser::UnoptimizedStringIO","CSV/Parser/UnoptimizedStringIO.html#method-c-new","(string)",""],["new","CSV::Row","CSV/Row.html#method-c-new","(headers, fields, header_row = false)","<p>Constructs a new CSV::Row from <code>headers</code> and <code>fields</code>, which are expected to be Arrays. If one Array is shorter …\n"],["new","CSV::Table","CSV/Table.html#method-c-new","(array_of_rows, headers: nil)","<p>Constructs a new CSV::Table from <code>array_of_rows</code>, which are expected to be CSV::Row objects. All rows are …\n"],["new","CSV::Writer","CSV/Writer.html#method-c-new","(output, options)",""],["normalize_converters","CSV","CSV.html#method-i-normalize_converters","(converters)",""],["open","CSV","CSV.html#method-c-open","(filename, mode=\"r\", **options)","<p>This method opens an IO object, and wraps that with CSV. This is intended as the primary interface for …\n"],["parse","CSV","CSV.html#method-c-parse","(str, **options, &block)","<p>This method can be used to easily parse CSV out of a String. You may either provide a <code>block</code> which will …\n"],["parse","CSV::Parser","CSV/Parser.html#method-i-parse","(&block)",""],["parse_column_end","CSV::Parser","CSV/Parser.html#method-i-parse_column_end","()",""],["parse_column_value","CSV::Parser","CSV/Parser.html#method-i-parse_column_value","()",""],["parse_headers","CSV::Parser","CSV/Parser.html#method-i-parse_headers","(row)",""],["parse_line","CSV","CSV.html#method-c-parse_line","(line, **options)","<p>This method is a shortcut for converting a single line of a CSV String into an Array. Note that if <code>line</code> …\n"],["parse_no_quote","CSV::Parser","CSV/Parser.html#method-i-parse_no_quote","(&block)",""],["parse_quotable_loose","CSV::Parser","CSV/Parser.html#method-i-parse_quotable_loose","(&block)",""],["parse_quotable_robust","CSV::Parser","CSV/Parser.html#method-i-parse_quotable_robust","(&block)",""],["parse_quoted_column_value","CSV::Parser","CSV/Parser.html#method-i-parse_quoted_column_value","()",""],["parse_row_end","CSV::Parser","CSV/Parser.html#method-i-parse_row_end","()",""],["parse_unquoted_column_value","CSV::Parser","CSV/Parser.html#method-i-parse_unquoted_column_value","()",""],["parser","CSV","CSV.html#method-i-parser","()",""],["parser_enumerator","CSV","CSV.html#method-i-parser_enumerator","()",""],["parser_fields_converter","CSV","CSV.html#method-i-parser_fields_converter","()",""],["parser_options","CSV","CSV.html#method-i-parser_options","()",""],["path","CSV","CSV.html#method-i-path","()",""],["prepare","CSV::Parser","CSV/Parser.html#method-i-prepare","()","<p>A set of tasks to prepare the file in order to parse it\n"],["prepare","CSV::Writer","CSV/Writer.html#method-i-prepare","()",""],["prepare_backslash","CSV::Parser","CSV/Parser.html#method-i-prepare_backslash","()",""],["prepare_format","CSV::Writer","CSV/Writer.html#method-i-prepare_format","()",""],["prepare_header","CSV::Parser","CSV/Parser.html#method-i-prepare_header","()",""],["prepare_header","CSV::Writer","CSV/Writer.html#method-i-prepare_header","()",""],["prepare_line","CSV::Parser","CSV/Parser.html#method-i-prepare_line","()",""],["prepare_output","CSV::Writer","CSV/Writer.html#method-i-prepare_output","()",""],["prepare_parser","CSV::Parser","CSV/Parser.html#method-i-prepare_parser","()",""],["prepare_quote_character","CSV::Parser","CSV/Parser.html#method-i-prepare_quote_character","()",""],["prepare_quoted","CSV::Parser","CSV/Parser.html#method-i-prepare_quoted","()",""],["prepare_separators","CSV::Parser","CSV/Parser.html#method-i-prepare_separators","()",""],["prepare_skip_lines","CSV::Parser","CSV/Parser.html#method-i-prepare_skip_lines","()",""],["prepare_strip","CSV::Parser","CSV/Parser.html#method-i-prepare_strip","()",""],["prepare_unquoted","CSV::Parser","CSV/Parser.html#method-i-prepare_unquoted","()",""],["prepare_variable","CSV::Parser","CSV/Parser.html#method-i-prepare_variable","()",""],["push","CSV::Row","CSV/Row.html#method-i-push","(*args)","<p>A shortcut for appending multiple fields. Equivalent to:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">args</span>.<span class=\"ruby-identifier\">each</span> { <span class=\"ruby-operator\">|</span><span class=\"ruby-identifier\">arg</span><span class=\"ruby-operator\">|</span> <span class=\"ruby-identifier\">csv_row</span> <span class=\"ruby-operator\">&lt;&lt;</span> <span class=\"ruby-identifier\">arg</span> }\n</pre>\n<p>This method …\n"],["push","CSV::Table","CSV/Table.html#method-i-push","(*rows)","<p>A shortcut for appending multiple rows. Equivalent to:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">rows</span>.<span class=\"ruby-identifier\">each</span> { <span class=\"ruby-operator\">|</span><span class=\"ruby-identifier\">row</span><span class=\"ruby-operator\">|</span> <span class=\"ruby-keyword\">self</span> <span class=\"ruby-operator\">&lt;&lt;</span> <span class=\"ruby-identifier\">row</span> }\n</pre>\n<p>This method returns …\n"],["puts","CSV","CSV.html#method-i-puts","(row)",""],["quote","CSV::Writer","CSV/Writer.html#method-i-quote","(field)",""],["quote_char","CSV","CSV.html#method-i-quote_char","()","<p>The encoded <code>:quote_char</code> used in parsing and writing. See CSV::new for details.\n"],["quote_character","CSV::Parser","CSV/Parser.html#method-i-quote_character","()",""],["quote_field","CSV::Writer","CSV/Writer.html#method-i-quote_field","(field)",""],["raw_encoding","CSV","CSV.html#method-i-raw_encoding","()","<p>Returns the encoding of the internal IO object.\n"],["read","CSV","CSV.html#method-i-read","()","<p>Slurps the remaining rows and returns an Array of Arrays.\n<p>The data source must be open for reading.\n"],["read","CSV","CSV.html#method-c-read","(path, **options)","<p>Use to slurp a CSV file into an Array of Arrays. Pass the <code>path</code> to the file and any <code>options</code> CSV::new() …\n"],["read_chunk","CSV::Parser::InputsScanner","CSV/Parser/InputsScanner.html#method-i-read_chunk","()",""],["readline","CSV","CSV.html#method-i-readline","()",""],["readlines","CSV","CSV.html#method-i-readlines","()",""],["readlines","CSV","CSV.html#method-c-readlines","(path, **options)","<p>Alias for CSV::read().\n"],["resolve_row_separator","CSV::Parser","CSV/Parser.html#method-i-resolve_row_separator","(separator)",""],["rest","CSV::Parser::InputsScanner","CSV/Parser/InputsScanner.html#method-i-rest","()",""],["return_headers?","CSV","CSV.html#method-i-return_headers-3F","()","<p>Returns <code>true</code> if headers will be returned as a row of results. See CSV::new for details.\n"],["return_headers?","CSV::Parser","CSV/Parser.html#method-i-return_headers-3F","()",""],["rewind","CSV","CSV.html#method-i-rewind","()","<p>Rewinds the underlying IO object and resets CSV&#39;s lineno() counter.\n"],["rewind","CSV::Writer","CSV/Writer.html#method-i-rewind","()","<p>Winds back to the beginning\n"],["row_sep","CSV","CSV.html#method-i-row_sep","()","<p>The encoded <code>:row_sep</code> used in parsing and writing. See CSV::new for details.\n"],["row_separator","CSV::Parser","CSV/Parser.html#method-i-row_separator","()",""],["scan","CSV::Parser::InputsScanner","CSV/Parser/InputsScanner.html#method-i-scan","(pattern)",""],["scan_all","CSV::Parser::InputsScanner","CSV/Parser/InputsScanner.html#method-i-scan_all","(pattern)",""],["shift","CSV","CSV.html#method-i-shift","()","<p>The primary read method for wrapped Strings and IOs, a single row is pulled from the data source, parsed …\n"],["skip_blanks?","CSV","CSV.html#method-i-skip_blanks-3F","()","<p>Returns <code>true</code> blank lines are skipped by the parser. See CSV::new for details.\n"],["skip_blanks?","CSV::Parser","CSV/Parser.html#method-i-skip_blanks-3F","()",""],["skip_line?","CSV::Parser","CSV/Parser.html#method-i-skip_line-3F","(line)",""],["skip_lines","CSV","CSV.html#method-i-skip_lines","()","<p>The regex marking a line as a comment. See CSV::new for details.\n"],["skip_lines","CSV::Parser","CSV/Parser.html#method-i-skip_lines","()",""],["skip_needless_lines","CSV::Parser","CSV/Parser.html#method-i-skip_needless_lines","()",""],["start_row","CSV::Parser","CSV/Parser.html#method-i-start_row","()",""],["stat","CSV","CSV.html#method-i-stat","(*args)",""],["strip_value","CSV::Parser","CSV/Parser.html#method-i-strip_value","(value)",""],["table","CSV","CSV.html#method-c-table","(path, **options)","<p>A shortcut for:\n\n<pre>CSV.read( path, { headers:           true,\n                  converters:        :numeric, ...</pre>\n"],["to_a","CSV::Table","CSV/Table.html#method-i-to_a","()","<p>Returns the table as an Array of Arrays. Headers will be the first row, then all of the field rows will …\n"],["to_csv","CSV::Row","CSV/Row.html#method-i-to_csv","(**options)","<p>Returns the row as a CSV String. Headers are not used. Equivalent to:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">csv_row</span>.<span class=\"ruby-identifier\">fields</span>.<span class=\"ruby-identifier\">to_csv</span>( <span class=\"ruby-identifier\">options</span> )\n</pre>\n"],["to_csv","CSV::Table","CSV/Table.html#method-i-to_csv","(write_headers: true, **options)","<p>Returns the table as a complete CSV String. Headers will be listed first, then all of the field rows. …\n"],["to_h","CSV::Row","CSV/Row.html#method-i-to_h","()","<p>Collapses the row into a simple Hash. Be warned that this discards field order and clobbers duplicate …\n"],["to_hash","CSV::Row","CSV/Row.html#method-i-to_hash","()",""],["to_i","CSV","CSV.html#method-i-to_i","()",""],["to_io","CSV","CSV.html#method-i-to_io","()",""],["to_s","CSV::Row","CSV/Row.html#method-i-to_s","(**options)",""],["to_s","CSV::Table","CSV/Table.html#method-i-to_s","(write_headers: true, **options)",""],["unconverted_fields?","CSV","CSV.html#method-i-unconverted_fields-3F","()","<p>Returns <code>true</code> if unconverted_fields() to parsed results. See CSV::new for details.\n"],["unconverted_fields?","CSV::Parser","CSV/Parser.html#method-i-unconverted_fields-3F","()",""],["use_headers?","CSV::Parser","CSV/Parser.html#method-i-use_headers-3F","()",""],["values_at","CSV::Row","CSV/Row.html#method-i-values_at","(*headers_and_or_indices)",""],["values_at","CSV::Table","CSV/Table.html#method-i-values_at","(*indices_or_headers)","<p>The mixed mode default is to treat a list of indices as row access, returning the rows indicated. Anything …\n"],["write_headers?","CSV","CSV.html#method-i-write_headers-3F","()","<p>Returns <code>true</code> if headers are written in output. See CSV::new for details.\n"],["writer","CSV","CSV.html#method-i-writer","()",""],["writer_fields_converter","CSV","CSV.html#method-i-writer_fields_converter","()",""],["writer_options","CSV","CSV.html#method-i-writer_options","()",""]]}}