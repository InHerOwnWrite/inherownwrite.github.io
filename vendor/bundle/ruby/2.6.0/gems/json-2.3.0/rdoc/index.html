<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>JSON implemention for Ruby</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
  var index_rel_prefix = "./";
</script>

<script src="./js/jquery.js"></script>
<script src="./js/darkfish.js"></script>

<link href="./css/fonts.css" rel="stylesheet">
<link href="./css/rdoc.css" rel="stylesheet">




<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="./index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="./table_of_contents.html#pages">Pages</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </div>
</div>


    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  <div id="project-metadata">
    <div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
  
    <li><a href="./README_md.html">README</a>
  
    <li><a href="./ext/json/Makefile.html">Makefile</a>
  
    <li><a href="./ext/json/ext/generator/Makefile.html">Makefile</a>
  
    <li><a href="./ext/json/ext/generator/depend.html">depend</a>
  
    <li><a href="./ext/json/ext/parser/Makefile.html">Makefile</a>
  
    <li><a href="./ext/json/ext/parser/depend.html">depend</a>
  
    <li><a href="./ext/json/ext/parser/parser_rl.html">parser.rl</a>
  
  </ul>
</div>

    <div id="classindex-section" class="nav-section">
  <h3>Class and Module Index</h3>

  <ul class="link-list">
  
    <li><a href="./BigDecimal.html">BigDecimal</a>
  
    <li><a href="./Class.html">Class</a>
  
    <li><a href="./Complex.html">Complex</a>
  
    <li><a href="./Date.html">Date</a>
  
    <li><a href="./DateTime.html">DateTime</a>
  
    <li><a href="./Exception.html">Exception</a>
  
    <li><a href="./JSON.html">JSON</a>
  
    <li><a href="./JSON/Ext.html">JSON::Ext</a>
  
    <li><a href="./JSON/Ext/Generator.html">JSON::Ext::Generator</a>
  
    <li><a href="./JSON/Ext/Generator/GeneratorMethods.html">JSON::Ext::Generator::GeneratorMethods</a>
  
    <li><a href="./JSON/Ext/Generator/GeneratorMethods/Array.html">JSON::Ext::Generator::GeneratorMethods::Array</a>
  
    <li><a href="./JSON/Ext/Generator/GeneratorMethods/Bignum.html">JSON::Ext::Generator::GeneratorMethods::Bignum</a>
  
    <li><a href="./JSON/Ext/Generator/GeneratorMethods/FalseClass.html">JSON::Ext::Generator::GeneratorMethods::FalseClass</a>
  
    <li><a href="./JSON/Ext/Generator/GeneratorMethods/Fixnum.html">JSON::Ext::Generator::GeneratorMethods::Fixnum</a>
  
    <li><a href="./JSON/Ext/Generator/GeneratorMethods/Float.html">JSON::Ext::Generator::GeneratorMethods::Float</a>
  
    <li><a href="./JSON/Ext/Generator/GeneratorMethods/Hash.html">JSON::Ext::Generator::GeneratorMethods::Hash</a>
  
    <li><a href="./JSON/Ext/Generator/GeneratorMethods/Integer.html">JSON::Ext::Generator::GeneratorMethods::Integer</a>
  
    <li><a href="./JSON/Ext/Generator/GeneratorMethods/NilClass.html">JSON::Ext::Generator::GeneratorMethods::NilClass</a>
  
    <li><a href="./JSON/Ext/Generator/GeneratorMethods/Object.html">JSON::Ext::Generator::GeneratorMethods::Object</a>
  
    <li><a href="./JSON/Ext/Generator/GeneratorMethods/String.html">JSON::Ext::Generator::GeneratorMethods::String</a>
  
    <li><a href="./JSON/Ext/Generator/GeneratorMethods/String/Extend.html">JSON::Ext::Generator::GeneratorMethods::String::Extend</a>
  
    <li><a href="./JSON/Ext/Generator/GeneratorMethods/TrueClass.html">JSON::Ext::Generator::GeneratorMethods::TrueClass</a>
  
    <li><a href="./JSON/Ext/Generator/State.html">JSON::Ext::Generator::State</a>
  
    <li><a href="./JSON/Ext/Parser.html">JSON::Ext::Parser</a>
  
    <li><a href="./JSON/GeneratorError.html">JSON::GeneratorError</a>
  
    <li><a href="./JSON/GenericObject.html">JSON::GenericObject</a>
  
    <li><a href="./JSON/JSONError.html">JSON::JSONError</a>
  
    <li><a href="./JSON/MissingUnicodeSupport.html">JSON::MissingUnicodeSupport</a>
  
    <li><a href="./JSON/NestingError.html">JSON::NestingError</a>
  
    <li><a href="./JSON/ParserError.html">JSON::ParserError</a>
  
    <li><a href="./JSON/Pure.html">JSON::Pure</a>
  
    <li><a href="./JSON/Pure/Generator.html">JSON::Pure::Generator</a>
  
    <li><a href="./JSON/Pure/Generator/GeneratorMethods.html">JSON::Pure::Generator::GeneratorMethods</a>
  
    <li><a href="./JSON/Pure/Generator/GeneratorMethods/Array.html">JSON::Pure::Generator::GeneratorMethods::Array</a>
  
    <li><a href="./JSON/Pure/Generator/GeneratorMethods/FalseClass.html">JSON::Pure::Generator::GeneratorMethods::FalseClass</a>
  
    <li><a href="./JSON/Pure/Generator/GeneratorMethods/Float.html">JSON::Pure::Generator::GeneratorMethods::Float</a>
  
    <li><a href="./JSON/Pure/Generator/GeneratorMethods/Hash.html">JSON::Pure::Generator::GeneratorMethods::Hash</a>
  
    <li><a href="./JSON/Pure/Generator/GeneratorMethods/Integer.html">JSON::Pure::Generator::GeneratorMethods::Integer</a>
  
    <li><a href="./JSON/Pure/Generator/GeneratorMethods/NilClass.html">JSON::Pure::Generator::GeneratorMethods::NilClass</a>
  
    <li><a href="./JSON/Pure/Generator/GeneratorMethods/Object.html">JSON::Pure::Generator::GeneratorMethods::Object</a>
  
    <li><a href="./JSON/Pure/Generator/GeneratorMethods/String.html">JSON::Pure::Generator::GeneratorMethods::String</a>
  
    <li><a href="./JSON/Pure/Generator/GeneratorMethods/String/Extend.html">JSON::Pure::Generator::GeneratorMethods::String::Extend</a>
  
    <li><a href="./JSON/Pure/Generator/GeneratorMethods/TrueClass.html">JSON::Pure::Generator::GeneratorMethods::TrueClass</a>
  
    <li><a href="./JSON/Pure/Generator/State.html">JSON::Pure::Generator::State</a>
  
    <li><a href="./JSON/Pure/Parser.html">JSON::Pure::Parser</a>
  
    <li><a href="./JSON/UnparserError.html">JSON::UnparserError</a>
  
    <li><a href="./Kernel.html">Kernel</a>
  
    <li><a href="./OpenStruct.html">OpenStruct</a>
  
    <li><a href="./Range.html">Range</a>
  
    <li><a href="./Rational.html">Rational</a>
  
    <li><a href="./Regexp.html">Regexp</a>
  
    <li><a href="./Set.html">Set</a>
  
    <li><a href="./Struct.html">Struct</a>
  
    <li><a href="./Symbol.html">Symbol</a>
  
    <li><a href="./Time.html">Time</a>
  
  </ul>
</div>

  </div>
</nav>

<main role="main">


<h1 id="label-JSON+implementation+for+Ruby"><a href="JSON.html"><code>JSON</code></a> implementation for Ruby<span><a href="#label-JSON+implementation+for+Ruby">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p><a href="https://travis-ci.org/flori/json"><img src="http://travis-ci.org/flori/json.svg?branch=master"></a></p>

<h2 id="label-Description">Description<span><a href="#label-Description">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>This is a implementation of the <a href="JSON.html"><code>JSON</code></a> specification according to RFC 7159 <a href="http://www.ietf.org/rfc/rfc7159.txt">www.ietf.org/rfc/rfc7159.txt</a> . Starting from version 1.0.0 on there will be two variants available:</p>
<ul><li>
<p>A pure ruby variant, that relies on the iconv and the stringscan  extensions, which are both part of the ruby standard library.</p>
</li><li>
<p>The quite a bit faster native extension variant, which is in parts  implemented in C or Java and comes with its own unicode conversion  functions and a parser generated by the ragel state machine compiler  <a href="http://www.complang.org/ragel">www.complang.org/ragel</a>/ .</p>
</li></ul>

<p>Both variants of the <a href="JSON.html"><code>JSON</code></a> generator generate UTF-8 character sequences by default. If an :ascii_only option with a true value is given, they escape all non-ASCII and control characters with uXXXX escape sequences, and support UTF-16 surrogate pairs in order to be able to generate the whole range of unicode code points.</p>

<p>All strings, that are to be encoded as <a href="JSON.html"><code>JSON</code></a> strings, should be UTF-8 byte sequences on the Ruby side. To encode raw binary strings, that aren&#39;t UTF-8 encoded, please use the to_json_raw_object method of String (which produces an object, that contains a byte array) and decode the result on the receiving endpoint.</p>

<h2 id="label-Installation">Installation<span><a href="#label-Installation">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>It&#39;s recommended to use the extension variant of <a href="JSON.html"><code>JSON</code></a>, because it&#39;s faster than the pure ruby variant. If you cannot build it on your system, you can settle for the latter.</p>

<p>Just type into the command line as root:</p>

<pre class="ruby"><span class="ruby-comment"># rake install</span>
</pre>

<p>The above command will build the extensions and install them on your system.</p>

<pre class="ruby"><span class="ruby-comment"># rake install_pure</span>
</pre>

<p>or</p>

<pre class="ruby"><span class="ruby-comment"># ruby install.rb</span>
</pre>

<p>will just install the pure ruby implementation of <a href="JSON.html"><code>JSON</code></a>.</p>

<p>If you use Rubygems you can type</p>

<pre class="ruby"><span class="ruby-comment"># gem install json</span>
</pre>

<p>instead, to install the newest <a href="JSON.html"><code>JSON</code></a> version.</p>

<p>There is also a pure ruby json only variant of the gem, that can be installed with:</p>

<pre class="ruby"><span class="ruby-comment"># gem install json_pure</span>
</pre>

<h2 id="label-Compiling+the+extensions+yourself">Compiling the extensions yourself<span><a href="#label-Compiling+the+extensions+yourself">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>If you want to create the <code>parser.c</code> file from its <code>parser.rl</code> file or draw nice graphviz images of the state machines, you need ragel from: <a href="http://www.complang.org/ragel">www.complang.org/ragel</a>/</p>

<h2 id="label-Usage">Usage<span><a href="#label-Usage">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>To use <a href="JSON.html"><code>JSON</code></a> you can</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;json&#39;</span>
</pre>

<p>to load the installed variant (either the extension <code>&#39;json&#39;</code> or the pure variant <code>&#39;json_pure&#39;</code>). If you have installed the extension variant, you can pick either the extension variant or the pure variant by typing</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;json/ext&#39;</span>
</pre>

<p>or</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;json/pure&#39;</span>
</pre>

<p>Now you can parse a <a href="JSON.html"><code>JSON</code></a> document into a ruby data structure by calling</p>

<pre class="ruby"><span class="ruby-constant">JSON</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-identifier">document</span>)
</pre>

<p>If you want to generate a <a href="JSON.html"><code>JSON</code></a> document from a ruby data structure call <code>ruby JSON.generate(data) </code></p>

<p>You can also use the <code>pretty_generate</code> method (which formats the output more verbosely and nicely) or <code>fast_generate</code> (which doesn&#39;t do any of the security checks generate performs, e. g. nesting deepness checks).</p>

<p>There are also the <a href="JSON.html"><code>JSON</code></a> and JSON[] methods which use parse on a String or generate a <a href="JSON.html"><code>JSON</code></a> document from an array or hash:</p>

<pre class="ruby"><span class="ruby-identifier">document</span> = <span class="ruby-constant">JSON</span> <span class="ruby-string">&#39;test&#39;</span>  <span class="ruby-operator">=&gt;</span> <span class="ruby-value">23</span> <span class="ruby-comment"># =&gt; &quot;{\&quot;test\&quot;:23}&quot;</span>
<span class="ruby-identifier">document</span> = <span class="ruby-constant">JSON</span>[<span class="ruby-string">&#39;test&#39;</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-value">23</span>] <span class="ruby-comment"># =&gt; &quot;{\&quot;test\&quot;:23}&quot;</span>
</pre>

<p>and</p>

<pre class="ruby"><span class="ruby-identifier">data</span> = <span class="ruby-constant">JSON</span> <span class="ruby-string">&#39;{&quot;test&quot;:23}&#39;</span>  <span class="ruby-comment"># =&gt; {&quot;test&quot;=&gt;23}</span>
<span class="ruby-identifier">data</span> = <span class="ruby-constant">JSON</span>[<span class="ruby-string">&#39;{&quot;test&quot;:23}&#39;</span>] <span class="ruby-comment"># =&gt; {&quot;test&quot;=&gt;23}</span>
</pre>

<p>You can choose to load a set of common additions to ruby core&#39;s objects if you</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;json/add/core&#39;</span>
</pre>

<p>After requiring this you can, e. g., serialise/deserialise Ruby ranges:</p>

<pre class="ruby"><span class="ruby-constant">JSON</span> <span class="ruby-constant">JSON</span>(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>) <span class="ruby-comment"># =&gt; 1..10</span>
</pre>

<p>To find out how to add <a href="JSON.html"><code>JSON</code></a> support to other or your own classes, read the section “More Examples” below.</p>

<p>To get the best compatibility to rails&#39; <a href="JSON.html"><code>JSON</code></a> implementation, you can</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;json/add/rails&#39;</span>
</pre>

<p>Both of the additions attempt to require <code>&#39;json&#39;</code> (like above) first, if it has not been required yet.</p>

<h2 id="label-Serializing+exceptions">Serializing exceptions<span><a href="#label-Serializing+exceptions">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The <a href="JSON.html"><code>JSON</code></a> module doesn&#39;t extend <code>Exception</code> by default. If you convert an <code>Exception</code> object to <a href="JSON.html"><code>JSON</code></a>, it will by default only include the exception message.</p>

<p>To include the full details, you must either load the <code>json/add/core</code> mentioned above, or specifically load the exception addition:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;json/add/exception&#39;</span>
</pre>

<h2 id="label-More+Examples">More Examples<span><a href="#label-More+Examples">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>To create a <a href="JSON.html"><code>JSON</code></a> document from a ruby data structure, you can call <code>JSON.generate</code> like that:</p>

<pre class="ruby"><span class="ruby-identifier">json</span> = <span class="ruby-constant">JSON</span>.<span class="ruby-identifier">generate</span> [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, {<span class="ruby-string">&quot;a&quot;</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">3.141</span>}, <span class="ruby-keyword">false</span>, <span class="ruby-keyword">true</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">4</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>]
<span class="ruby-comment"># =&gt; &quot;[1,2,{\&quot;a\&quot;:3.141},false,true,null,\&quot;4..10\&quot;]&quot;</span>
</pre>

<p>To get back a ruby data structure from a <a href="JSON.html"><code>JSON</code></a> document, you have to call <a href="JSON.html#method-i-parse"><code>JSON.parse</code></a> on it:</p>

<pre class="ruby"><span class="ruby-constant">JSON</span>.<span class="ruby-identifier">parse</span> <span class="ruby-identifier">json</span>
<span class="ruby-comment"># =&gt; [1, 2, {&quot;a&quot;=&gt;3.141}, false, true, nil, &quot;4..10&quot;]</span>
</pre>

<p>Note, that the range from the original data structure is a simple string now. The reason for this is, that <a href="JSON.html"><code>JSON</code></a> doesn&#39;t support ranges or arbitrary classes. In this case the json library falls back to call <code>Object#to_json</code>, which is the same as <code>#to_s.to_json</code>.</p>

<p>It&#39;s possible to add <a href="JSON.html"><code>JSON</code></a> support serialization to arbitrary classes by simply implementing a more specialized version of the <code>#to_json method</code>, that should return a <a href="JSON.html"><code>JSON</code></a> object (a hash converted to <a href="JSON.html"><code>JSON</code></a> with <code>#to_json</code>) like this (don&#39;t forget the <code>*a</code> for all the arguments):</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Range</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_json</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">a</span>)
    {
      <span class="ruby-string">&#39;json_class&#39;</span>   <span class="ruby-operator">=&gt;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">name</span>, <span class="ruby-comment"># = &#39;Range&#39;</span>
      <span class="ruby-string">&#39;data&#39;</span>         <span class="ruby-operator">=&gt;</span> [ <span class="ruby-identifier">first</span>, <span class="ruby-identifier">last</span>, <span class="ruby-identifier">exclude_end?</span> ]
    }.<span class="ruby-identifier">to_json</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">a</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>The hash key <code>json_class</code> is the class, that will be asked to deserialise the <a href="JSON.html"><code>JSON</code></a> representation later. In this case it&#39;s <code>Range</code>, but any namespace of the form <code>A::B</code> or <code>::A::B</code> will do. All other keys are arbitrary and can be used to store the necessary data to configure the object to be deserialised.</p>

<p>If the key <code>json_class</code> is found in a <a href="JSON.html"><code>JSON</code></a> object, the <a href="JSON.html"><code>JSON</code></a> parser checks if the given class responds to the <code>json_create</code> class method. If so, it is called with the <a href="JSON.html"><code>JSON</code></a> object converted to a Ruby hash. So a range can be deserialised by implementing <code>Range.json_create</code> like this:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Range</span>
  <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier ruby-title">json_create</span>(<span class="ruby-identifier">o</span>)
    <span class="ruby-identifier">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">o</span>[<span class="ruby-string">&#39;data&#39;</span>])
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Now it possible to serialise/deserialise ranges as well:</p>

<pre class="ruby"><span class="ruby-identifier">json</span> = <span class="ruby-constant">JSON</span>.<span class="ruby-identifier">generate</span> [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, {<span class="ruby-string">&quot;a&quot;</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">3.141</span>}, <span class="ruby-keyword">false</span>, <span class="ruby-keyword">true</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">4</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>]
<span class="ruby-comment"># =&gt; &quot;[1,2,{\&quot;a\&quot;:3.141},false,true,null,{\&quot;json_class\&quot;:\&quot;Range\&quot;,\&quot;data\&quot;:[4,10,false]}]&quot;</span>
<span class="ruby-constant">JSON</span>.<span class="ruby-identifier">parse</span> <span class="ruby-identifier">json</span>
<span class="ruby-comment"># =&gt; [1, 2, {&quot;a&quot;=&gt;3.141}, false, true, nil, 4..10]</span>
<span class="ruby-identifier">json</span> = <span class="ruby-constant">JSON</span>.<span class="ruby-identifier">generate</span> [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, {<span class="ruby-string">&quot;a&quot;</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">3.141</span>}, <span class="ruby-keyword">false</span>, <span class="ruby-keyword">true</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">4</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>]
<span class="ruby-comment"># =&gt; &quot;[1,2,{\&quot;a\&quot;:3.141},false,true,null,{\&quot;json_class\&quot;:\&quot;Range\&quot;,\&quot;data\&quot;:[4,10,false]}]&quot;</span>
<span class="ruby-constant">JSON</span>.<span class="ruby-identifier">parse</span> <span class="ruby-identifier">json</span>, <span class="ruby-value">:create_additions</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-keyword">true</span>
<span class="ruby-comment"># =&gt; [1, 2, {&quot;a&quot;=&gt;3.141}, false, true, nil, 4..10]</span>
</pre>

<p><code>JSON.generate</code> always creates the shortest possible string representation of a ruby data structure in one line. This is good for data storage or network protocols, but not so good for humans to read. Fortunately there&#39;s also <code>JSON.pretty_generate</code> (or <code>JSON.pretty_generate</code>) that creates a more readable output:</p>

<pre class="ruby"><span class="ruby-identifier">puts</span> <span class="ruby-constant">JSON</span>.<span class="ruby-identifier">pretty_generate</span>([<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, {<span class="ruby-string">&quot;a&quot;</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">3.141</span>}, <span class="ruby-keyword">false</span>, <span class="ruby-keyword">true</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">4</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>])
 [
   <span class="ruby-value">1</span>,
   <span class="ruby-value">2</span>,
   {
     <span class="ruby-value">&quot;a&quot;:</span> <span class="ruby-value">3.141</span>
   },
   <span class="ruby-keyword">false</span>,
   <span class="ruby-keyword">true</span>,
   <span class="ruby-identifier">null</span>,
   {
     <span class="ruby-value">&quot;json_class&quot;:</span> <span class="ruby-string">&quot;Range&quot;</span>,
     <span class="ruby-value">&quot;data&quot;:</span> [
       <span class="ruby-value">4</span>,
       <span class="ruby-value">10</span>,
       <span class="ruby-keyword">false</span>
     ]
   }
 ]
</pre>

<p>There are also the methods <code>Kernel#j</code> for generate, and <code>Kernel#jj</code> for <code>pretty_generate</code> output to the console, that work analogous to Core Ruby&#39;s <code>p</code> and the <code>pp</code> library&#39;s <code>pp</code> methods.</p>

<p>The script <code>tools/server.rb</code> contains a small example if you want to test, how receiving a <a href="JSON.html"><code>JSON</code></a> object from a webrick server in your browser with the javasript prototype library <a href="http://www.prototypejs.org">www.prototypejs.org</a> works.</p>

<h2 id="label-Speed+Comparisons">Speed Comparisons<span><a href="#label-Speed+Comparisons">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>I have created some benchmark results (see the benchmarks/data-p4-3Ghz subdir of the package) for the JSON-parser to estimate the speed up in the C extension:</p>

<pre>Comparing times (call_time_mean):
  1 ParserBenchmarkExt#parser   900 repeats:
        553.922304770 (  real) -&gt;   21.500x
          0.001805307
  2 ParserBenchmarkYAML#parser  1000 repeats:
        224.513358139 (  real) -&gt;    8.714x
          0.004454078
  3 ParserBenchmarkPure#parser  1000 repeats:
         26.755020642 (  real) -&gt;    1.038x
          0.037376163
  4 ParserBenchmarkRails#parser 1000 repeats:
         25.763381731 (  real) -&gt;    1.000x
          0.038814780
            calls/sec (  time) -&gt;    speed  covers
            secs/call</pre>

<p>In the table above 1 is <code>JSON::Ext::Parser</code>, 2 is <code>YAML.load</code> with YAML compatbile <a href="JSON.html"><code>JSON</code></a> document, 3 is is <code>JSON::Pure::Parser</code>, and 4 is <code>ActiveSupport::JSON.decode</code>. The ActiveSupport JSON-decoder converts the input first to YAML and then uses the YAML-parser, the conversion seems to slow it down so much that it is only as fast as the <code>JSON::Pure::Parser</code>!</p>

<p>If you look at the benchmark data you can see that this is mostly caused by the frequent high outliers - the median of the Rails-parser runs is still overall smaller than the median of the <code>JSON::Pure::Parser</code> runs:</p>

<pre>Comparing times (call_time_median):
  1 ParserBenchmarkExt#parser   900 repeats:
        800.592479481 (  real) -&gt;   26.936x
          0.001249075
  2 ParserBenchmarkYAML#parser  1000 repeats:
        271.002390644 (  real) -&gt;    9.118x
          0.003690004
  3 ParserBenchmarkRails#parser 1000 repeats:
         30.227910865 (  real) -&gt;    1.017x
          0.033082008
  4 ParserBenchmarkPure#parser  1000 repeats:
         29.722384421 (  real) -&gt;    1.000x
          0.033644676
            calls/sec (  time) -&gt;    speed  covers
            secs/call</pre>

<p>I have benchmarked the <code>JSON-Generator</code> as well. This generated a few more values, because there are different modes that also influence the achieved speed:</p>

<pre>Comparing times (call_time_mean):
  1 GeneratorBenchmarkExt#generator_fast    1000 repeats:
        547.354332608 (  real) -&gt;   15.090x
          0.001826970
  2 GeneratorBenchmarkExt#generator_safe    1000 repeats:
        443.968212317 (  real) -&gt;   12.240x
          0.002252414
  3 GeneratorBenchmarkExt#generator_pretty  900 repeats:
        375.104545883 (  real) -&gt;   10.341x
          0.002665923
  4 GeneratorBenchmarkPure#generator_fast   1000 repeats:
         49.978706968 (  real) -&gt;    1.378x
          0.020008521
  5 GeneratorBenchmarkRails#generator       1000 repeats:
         38.531868759 (  real) -&gt;    1.062x
          0.025952543
  6 GeneratorBenchmarkPure#generator_safe   1000 repeats:
         36.927649925 (  real) -&gt;    1.018x 7 (&gt;=3859)
          0.027079979
  7 GeneratorBenchmarkPure#generator_pretty 1000 repeats:
         36.272134441 (  real) -&gt;    1.000x 6 (&gt;=3859)
          0.027569373
            calls/sec (  time) -&gt;    speed  covers
            secs/call</pre>

<p>In the table above 1-3 are <code>JSON::Ext::Generator</code> methods. 4, 6, and 7 are <code>JSON::Pure::Generator</code> methods and 5 is the Rails <a href="JSON.html"><code>JSON</code></a> generator. It is now a bit faster than the <code>generator_safe</code> and <code>generator_pretty</code> methods of the pure variant but slower than the others.</p>

<p>To achieve the fastest <a href="JSON.html"><code>JSON</code></a> document output, you can use the <code>fast_generate</code> method. Beware, that this will disable the checking for circular Ruby data structures, which may cause <a href="JSON.html"><code>JSON</code></a> to go into an infinite loop.</p>

<p>Here are the median comparisons for completeness&#39; sake:</p>

<pre>Comparing times (call_time_median):
  1 GeneratorBenchmarkExt#generator_fast    1000 repeats:
        708.258020939 (  real) -&gt;   16.547x
          0.001411915
  2 GeneratorBenchmarkExt#generator_safe    1000 repeats:
        569.105020353 (  real) -&gt;   13.296x
          0.001757145
  3 GeneratorBenchmarkExt#generator_pretty  900 repeats:
        482.825371244 (  real) -&gt;   11.280x
          0.002071142
  4 GeneratorBenchmarkPure#generator_fast   1000 repeats:
         62.717626652 (  real) -&gt;    1.465x
          0.015944481
  5 GeneratorBenchmarkRails#generator       1000 repeats:
         43.965681162 (  real) -&gt;    1.027x
          0.022745013
  6 GeneratorBenchmarkPure#generator_safe   1000 repeats:
         43.929073409 (  real) -&gt;    1.026x 7 (&gt;=3859)
          0.022763968
  7 GeneratorBenchmarkPure#generator_pretty 1000 repeats:
         42.802514491 (  real) -&gt;    1.000x 6 (&gt;=3859)
          0.023363113
            calls/sec (  time) -&gt;    speed  covers
            secs/call</pre>

<h2 id="label-Author">Author<span><a href="#label-Author">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Florian Frank <a href="mailto:flori@ping.de">flori@ping.de</a></p>

<h2 id="label-License">License<span><a href="#label-License">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Ruby License, see <a href="https://www.ruby-lang.org/en/about/license.txt">www.ruby-lang.org/en/about/license.txt</a>.</p>

<h2 id="label-Download">Download<span><a href="#label-Download">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The latest version of this library can be downloaded at</p>
<ul><li>
<p><a href="https://rubygems.org/gems/json">rubygems.org/gems/json</a></p>
</li></ul>

<p>Online Documentation should be located at</p>
<ul><li>
<p><a href="https://www.rubydoc.info/gems/json">www.rubydoc.info/gems/json</a></p>
</li></ul>


</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.1.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

